var Us = Object.defineProperty;
var Vs = (n, e, t) => e in n ? Us(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t;
var Le = (n, e, t) => (Vs(n, typeof e != "symbol" ? e + "" : e, t), t);
import Ye, { createContext as Nr, useContext as X, useEffect as Je, useLayoutEffect as js, useRef as Ne, useMemo as Pr, useCallback as V, useDebugValue as $s, useState as D } from "react";
var I = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, Mt = {}, et = {}, ut = {}, Dt = I && I.__assign || function() {
  return Dt = Object.assign || function(n) {
    for (var e, t = 1, r = arguments.length; t < r; t++) {
      e = arguments[t];
      for (var s in e)
        Object.prototype.hasOwnProperty.call(e, s) && (n[s] = e[s]);
    }
    return n;
  }, Dt.apply(this, arguments);
}, gt = I && I.__awaiter || function(n, e, t, r) {
  function s(i) {
    return i instanceof t ? i : new t(function(o) {
      o(i);
    });
  }
  return new (t || (t = Promise))(function(i, o) {
    function c(h) {
      try {
        a(r.next(h));
      } catch (l) {
        o(l);
      }
    }
    function f(h) {
      try {
        a(r.throw(h));
      } catch (l) {
        o(l);
      }
    }
    function a(h) {
      h.done ? i(h.value) : s(h.value).then(c, f);
    }
    a((r = r.apply(n, e || [])).next());
  });
}, _t = I && I.__generator || function(n, e) {
  var t = { label: 0, sent: function() {
    if (i[0] & 1)
      throw i[1];
    return i[1];
  }, trys: [], ops: [] }, r, s, i, o;
  return o = { next: c(0), throw: c(1), return: c(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function c(a) {
    return function(h) {
      return f([a, h]);
    };
  }
  function f(a) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; t; )
      try {
        if (r = 1, s && (i = a[0] & 2 ? s.return : a[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, a[1])).done)
          return i;
        switch (s = 0, i && (a = [a[0] & 2, i.value]), a[0]) {
          case 0:
          case 1:
            i = a;
            break;
          case 4:
            return t.label++, { value: a[1], done: !1 };
          case 5:
            t.label++, s = a[1], a = [0];
            continue;
          case 7:
            a = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (a[0] === 6 || a[0] === 2)) {
              t = 0;
              continue;
            }
            if (a[0] === 3 && (!i || a[1] > i[0] && a[1] < i[3])) {
              t.label = a[1];
              break;
            }
            if (a[0] === 6 && t.label < i[1]) {
              t.label = i[1], i = a;
              break;
            }
            if (i && t.label < i[2]) {
              t.label = i[2], t.ops.push(a);
              break;
            }
            i[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        a = e.call(n, t);
      } catch (h) {
        a = [6, h], s = 0;
      } finally {
        r = i = 0;
      }
    if (a[0] & 5)
      throw a[1];
    return { value: a[0] ? a[1] : void 0, done: !0 };
  }
};
Object.defineProperty(ut, "__esModule", { value: !0 });
ut.FrappeCall = void 0;
var Ms = function() {
  function n(e, t, r, s, i) {
    this.appURL = e, this.axios = t, this.useToken = r != null ? r : !1, this.token = s, this.tokenType = i;
  }
  return n.prototype.get = function(e, t) {
    return gt(this, void 0, void 0, function() {
      return _t(this, function(r) {
        return [2, this.axios.get("/api/method/".concat(e), { params: t }).then(function(s) {
          return s.data;
        }).catch(function(s) {
          var i, o;
          throw {
            httpStatus: s.response.status,
            httpStatusText: s.response.statusText,
            message: (i = s.response.data.message) !== null && i !== void 0 ? i : "There was an error.",
            exception: (o = s.response.data.exception) !== null && o !== void 0 ? o : ""
          };
        })];
      });
    });
  }, n.prototype.post = function(e, t) {
    return gt(this, void 0, void 0, function() {
      return _t(this, function(r) {
        return [2, this.axios.post("/api/method/".concat(e), Dt({}, t)).then(function(s) {
          return s.data;
        }).catch(function(s) {
          var i, o;
          throw {
            httpStatus: s.response.status,
            httpStatusText: s.response.statusText,
            message: (i = s.response.data.message) !== null && i !== void 0 ? i : "There was an error.",
            exception: (o = s.response.data.exception) !== null && o !== void 0 ? o : ""
          };
        })];
      });
    });
  }, n.prototype.put = function(e, t) {
    return gt(this, void 0, void 0, function() {
      return _t(this, function(r) {
        return [2, this.axios.put("/api/method/".concat(e), Dt({}, t)).then(function(s) {
          return s.data;
        }).catch(function(s) {
          var i, o;
          throw {
            httpStatus: s.response.status,
            httpStatusText: s.response.statusText,
            message: (i = s.response.data.message) !== null && i !== void 0 ? i : "There was an error.",
            exception: (o = s.response.data.exception) !== null && o !== void 0 ? o : ""
          };
        })];
      });
    });
  }, n.prototype.delete = function(e, t) {
    return gt(this, void 0, void 0, function() {
      return _t(this, function(r) {
        return [2, this.axios.delete("/api/method/".concat(e), { params: t }).then(function(s) {
          return s.data;
        }).catch(function(s) {
          var i, o;
          throw {
            httpStatus: s.response.status,
            httpStatusText: s.response.statusText,
            message: (i = s.response.data.message) !== null && i !== void 0 ? i : "There was an error.",
            exception: (o = s.response.data.exception) !== null && o !== void 0 ? o : ""
          };
        })];
      });
    });
  }, n;
}();
ut.FrappeCall = Ms;
var ct = {}, Oe = I && I.__assign || function() {
  return Oe = Object.assign || function(n) {
    for (var e, t = 1, r = arguments.length; t < r; t++) {
      e = arguments[t];
      for (var s in e)
        Object.prototype.hasOwnProperty.call(e, s) && (n[s] = e[s]);
    }
    return n;
  }, Oe.apply(this, arguments);
}, Pe = I && I.__awaiter || function(n, e, t, r) {
  function s(i) {
    return i instanceof t ? i : new t(function(o) {
      o(i);
    });
  }
  return new (t || (t = Promise))(function(i, o) {
    function c(h) {
      try {
        a(r.next(h));
      } catch (l) {
        o(l);
      }
    }
    function f(h) {
      try {
        a(r.throw(h));
      } catch (l) {
        o(l);
      }
    }
    function a(h) {
      h.done ? i(h.value) : s(h.value).then(c, f);
    }
    a((r = r.apply(n, e || [])).next());
  });
}, Be = I && I.__generator || function(n, e) {
  var t = { label: 0, sent: function() {
    if (i[0] & 1)
      throw i[1];
    return i[1];
  }, trys: [], ops: [] }, r, s, i, o;
  return o = { next: c(0), throw: c(1), return: c(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function c(a) {
    return function(h) {
      return f([a, h]);
    };
  }
  function f(a) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; t; )
      try {
        if (r = 1, s && (i = a[0] & 2 ? s.return : a[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, a[1])).done)
          return i;
        switch (s = 0, i && (a = [a[0] & 2, i.value]), a[0]) {
          case 0:
          case 1:
            i = a;
            break;
          case 4:
            return t.label++, { value: a[1], done: !1 };
          case 5:
            t.label++, s = a[1], a = [0];
            continue;
          case 7:
            a = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (a[0] === 6 || a[0] === 2)) {
              t = 0;
              continue;
            }
            if (a[0] === 3 && (!i || a[1] > i[0] && a[1] < i[3])) {
              t.label = a[1];
              break;
            }
            if (a[0] === 6 && t.label < i[1]) {
              t.label = i[1], i = a;
              break;
            }
            if (i && t.label < i[2]) {
              t.label = i[2], t.ops.push(a);
              break;
            }
            i[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        a = e.call(n, t);
      } catch (h) {
        a = [6, h], s = 0;
      } finally {
        r = i = 0;
      }
    if (a[0] & 5)
      throw a[1];
    return { value: a[0] ? a[1] : void 0, done: !0 };
  }
};
Object.defineProperty(ct, "__esModule", { value: !0 });
ct.FrappeDB = void 0;
var Ws = function() {
  function n(e, t, r, s, i) {
    this.appURL = e, this.axios = t, this.useToken = r != null ? r : !1, this.token = s, this.tokenType = i;
  }
  return n.prototype.getDoc = function(e, t) {
    return Pe(this, void 0, void 0, function() {
      return Be(this, function(r) {
        return [2, this.axios.get("/api/resource/".concat(e, "/").concat(t)).then(function(s) {
          return s.data.data;
        }).catch(function(s) {
          var i, o;
          throw {
            httpStatus: s.response.status,
            httpStatusText: s.response.statusText,
            message: "There was an error while fetching the document.",
            exception: (o = (i = s.response.data.exception) !== null && i !== void 0 ? i : s.response.data.exc_type) !== null && o !== void 0 ? o : ""
          };
        })];
      });
    });
  }, n.prototype.getDocList = function(e, t) {
    var r;
    return Pe(this, void 0, void 0, function() {
      var s, i, o, c, f, a, h, l, v, p, b;
      return Be(this, function(w) {
        return s = {}, t && (i = t.fields, o = t.filters, c = t.orFilters, f = t.orderBy, a = t.limit, h = t.limit_start, l = t.groupBy, v = t.asDict, p = v === void 0 ? !0 : v, b = f ? "".concat(f == null ? void 0 : f.field, " ").concat((r = f == null ? void 0 : f.order) !== null && r !== void 0 ? r : "asc") : "", s = {
          fields: i ? JSON.stringify(i) : void 0,
          filters: o ? JSON.stringify(o) : void 0,
          or_filters: c ? JSON.stringify(c) : void 0,
          order_by: b,
          group_by: l,
          limit: a,
          limit_start: h,
          as_dict: p
        }), [2, this.axios.get("/api/resource/".concat(e), { params: s }).then(function(g) {
          return g.data.data;
        }).catch(function(g) {
          var L, R;
          throw {
            httpStatus: g.response.status,
            httpStatusText: g.response.statusText,
            message: "There was an error while fetching the documents.",
            exception: (R = (L = g.response.data.exception) !== null && L !== void 0 ? L : g.response.data.exc_type) !== null && R !== void 0 ? R : ""
          };
        })];
      });
    });
  }, n.prototype.createDoc = function(e, t) {
    return Pe(this, void 0, void 0, function() {
      return Be(this, function(r) {
        return [2, this.axios.post("/api/resource/".concat(e), Oe({}, t)).then(function(s) {
          return s.data.data;
        }).catch(function(s) {
          var i, o, c;
          throw {
            httpStatus: s.response.status,
            httpStatusText: s.response.statusText,
            message: (i = s.response.data.message) !== null && i !== void 0 ? i : "There was an error while creating the document.",
            exception: (c = (o = s.response.data.exception) !== null && o !== void 0 ? o : s.response.data.exc_type) !== null && c !== void 0 ? c : ""
          };
        })];
      });
    });
  }, n.prototype.updateDoc = function(e, t, r) {
    return Pe(this, void 0, void 0, function() {
      return Be(this, function(s) {
        return [2, this.axios.put("/api/resource/".concat(e, "/").concat(t), Oe({}, r)).then(function(i) {
          return i.data.data;
        }).catch(function(i) {
          var o, c, f;
          throw {
            httpStatus: i.response.status,
            httpStatusText: i.response.statusText,
            message: (o = i.response.data.message) !== null && o !== void 0 ? o : "There was an error while updating the document.",
            exception: (f = (c = i.response.data.exception) !== null && c !== void 0 ? c : i.response.data.exc_type) !== null && f !== void 0 ? f : ""
          };
        })];
      });
    });
  }, n.prototype.deleteDoc = function(e, t) {
    return Pe(this, void 0, void 0, function() {
      return Be(this, function(r) {
        return [2, this.axios.delete("/api/resource/".concat(e, "/").concat(t)).then(function(s) {
          return s.data;
        }).catch(function(s) {
          var i, o;
          throw {
            httpStatus: s.response.status,
            httpStatusText: s.response.statusText,
            message: "There was an error while deleting the document.",
            exception: (o = (i = s.response.data.exception) !== null && i !== void 0 ? i : s.response.data.exc_type) !== null && o !== void 0 ? o : ""
          };
        })];
      });
    });
  }, n.prototype.getCount = function(e, t, r, s) {
    return r === void 0 && (r = !1), s === void 0 && (s = !1), Pe(this, void 0, void 0, function() {
      var i;
      return Be(this, function(o) {
        return i = {
          doctype: e,
          filters: []
        }, r && (i.cache = r), s && (i.debug = s), t && (i.filters = t ? JSON.stringify(t) : void 0), [2, this.axios.get("/api/method/frappe.client.get_count", { params: i }).then(function(c) {
          return c.data.message;
        }).catch(function(c) {
          var f, a;
          throw {
            httpStatus: c.response.status,
            httpStatusText: c.response.statusText,
            message: "There was an error while getting the count.",
            exception: (a = (f = c.response.data.exception) !== null && f !== void 0 ? f : c.response.data.exc_type) !== null && a !== void 0 ? a : ""
          };
        })];
      });
    });
  }, n.prototype.getLastDoc = function(e, t) {
    return Pe(this, void 0, void 0, function() {
      var r, s;
      return Be(this, function(i) {
        switch (i.label) {
          case 0:
            return r = {
              orderBy: {
                field: "creation",
                order: "desc"
              }
            }, t && (r = Oe(Oe({}, r), t)), [4, this.getDocList(e, Oe(Oe({}, r), { limit: 1 }))];
          case 1:
            return s = i.sent(), s.length > 0 ? [2, this.getDoc(e, s[0].name)] : [2, {}];
        }
      });
    });
  }, n;
}();
ct.FrappeDB = Ws;
var lt = {}, Hs = I && I.__awaiter || function(n, e, t, r) {
  function s(i) {
    return i instanceof t ? i : new t(function(o) {
      o(i);
    });
  }
  return new (t || (t = Promise))(function(i, o) {
    function c(h) {
      try {
        a(r.next(h));
      } catch (l) {
        o(l);
      }
    }
    function f(h) {
      try {
        a(r.throw(h));
      } catch (l) {
        o(l);
      }
    }
    function a(h) {
      h.done ? i(h.value) : s(h.value).then(c, f);
    }
    a((r = r.apply(n, e || [])).next());
  });
}, Ys = I && I.__generator || function(n, e) {
  var t = { label: 0, sent: function() {
    if (i[0] & 1)
      throw i[1];
    return i[1];
  }, trys: [], ops: [] }, r, s, i, o;
  return o = { next: c(0), throw: c(1), return: c(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function c(a) {
    return function(h) {
      return f([a, h]);
    };
  }
  function f(a) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; t; )
      try {
        if (r = 1, s && (i = a[0] & 2 ? s.return : a[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, a[1])).done)
          return i;
        switch (s = 0, i && (a = [a[0] & 2, i.value]), a[0]) {
          case 0:
          case 1:
            i = a;
            break;
          case 4:
            return t.label++, { value: a[1], done: !1 };
          case 5:
            t.label++, s = a[1], a = [0];
            continue;
          case 7:
            a = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (a[0] === 6 || a[0] === 2)) {
              t = 0;
              continue;
            }
            if (a[0] === 3 && (!i || a[1] > i[0] && a[1] < i[3])) {
              t.label = a[1];
              break;
            }
            if (a[0] === 6 && t.label < i[1]) {
              t.label = i[1], i = a;
              break;
            }
            if (i && t.label < i[2]) {
              t.label = i[2], t.ops.push(a);
              break;
            }
            i[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        a = e.call(n, t);
      } catch (h) {
        a = [6, h], s = 0;
      } finally {
        r = i = 0;
      }
    if (a[0] & 5)
      throw a[1];
    return { value: a[0] ? a[1] : void 0, done: !0 };
  }
};
Object.defineProperty(lt, "__esModule", { value: !0 });
lt.FrappeFileUpload = void 0;
var Js = function() {
  function n(e, t, r, s, i) {
    this.appURL = e, this.axios = t, this.useToken = r != null ? r : !1, this.token = s, this.tokenType = i;
  }
  return n.prototype.uploadFile = function(e, t, r) {
    return Hs(this, void 0, void 0, function() {
      var s, i, o, c, f, a, h;
      return Ys(this, function(l) {
        return s = new FormData(), e && s.append("file", e, e.name), i = t.isPrivate, o = t.folder, c = t.file_url, f = t.doctype, a = t.docname, h = t.fieldname, i && s.append("is_private", "1"), o && s.append("folder", o), c && s.append("file_url", c), f && a && (s.append("doctype", f), s.append("docname", a), h && s.append("fieldname", h)), [2, this.axios.post("/api/method/upload_file", s, {
          onUploadProgress: function(v) {
            r && r(v.loaded, v.total);
          }
        }).catch(function(v) {
          var p, b;
          throw {
            httpStatus: v.response.status,
            httpStatusText: v.response.statusText,
            message: (p = v.response.data.message) !== null && p !== void 0 ? p : "There was an error while uploading the file.",
            exception: (b = v.response.data.exception) !== null && b !== void 0 ? b : ""
          };
        })];
      });
    });
  }, n;
}();
lt.FrappeFileUpload = Js;
var He = {}, Br = { exports: {} }, Cn = { exports: {} }, Fr = function(e, t) {
  return function() {
    for (var s = new Array(arguments.length), i = 0; i < s.length; i++)
      s[i] = arguments[i];
    return e.apply(t, s);
  };
}, zs = Fr, ke = Object.prototype.toString;
function An(n) {
  return Array.isArray(n);
}
function vn(n) {
  return typeof n > "u";
}
function Ks(n) {
  return n !== null && !vn(n) && n.constructor !== null && !vn(n.constructor) && typeof n.constructor.isBuffer == "function" && n.constructor.isBuffer(n);
}
function Ir(n) {
  return ke.call(n) === "[object ArrayBuffer]";
}
function Gs(n) {
  return ke.call(n) === "[object FormData]";
}
function Xs(n) {
  var e;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? e = ArrayBuffer.isView(n) : e = n && n.buffer && Ir(n.buffer), e;
}
function Qs(n) {
  return typeof n == "string";
}
function Zs(n) {
  return typeof n == "number";
}
function qr(n) {
  return n !== null && typeof n == "object";
}
function Ot(n) {
  if (ke.call(n) !== "[object Object]")
    return !1;
  var e = Object.getPrototypeOf(n);
  return e === null || e === Object.prototype;
}
function ei(n) {
  return ke.call(n) === "[object Date]";
}
function ti(n) {
  return ke.call(n) === "[object File]";
}
function ni(n) {
  return ke.call(n) === "[object Blob]";
}
function Ur(n) {
  return ke.call(n) === "[object Function]";
}
function ri(n) {
  return qr(n) && Ur(n.pipe);
}
function si(n) {
  return ke.call(n) === "[object URLSearchParams]";
}
function ii(n) {
  return n.trim ? n.trim() : n.replace(/^\s+|\s+$/g, "");
}
function oi() {
  return typeof navigator < "u" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS") ? !1 : typeof window < "u" && typeof document < "u";
}
function kn(n, e) {
  if (!(n === null || typeof n > "u"))
    if (typeof n != "object" && (n = [n]), An(n))
      for (var t = 0, r = n.length; t < r; t++)
        e.call(null, n[t], t, n);
    else
      for (var s in n)
        Object.prototype.hasOwnProperty.call(n, s) && e.call(null, n[s], s, n);
}
function mn() {
  var n = {};
  function e(s, i) {
    Ot(n[i]) && Ot(s) ? n[i] = mn(n[i], s) : Ot(s) ? n[i] = mn({}, s) : An(s) ? n[i] = s.slice() : n[i] = s;
  }
  for (var t = 0, r = arguments.length; t < r; t++)
    kn(arguments[t], e);
  return n;
}
function ai(n, e, t) {
  return kn(e, function(s, i) {
    t && typeof s == "function" ? n[i] = zs(s, t) : n[i] = s;
  }), n;
}
function ui(n) {
  return n.charCodeAt(0) === 65279 && (n = n.slice(1)), n;
}
var oe = {
  isArray: An,
  isArrayBuffer: Ir,
  isBuffer: Ks,
  isFormData: Gs,
  isArrayBufferView: Xs,
  isString: Qs,
  isNumber: Zs,
  isObject: qr,
  isPlainObject: Ot,
  isUndefined: vn,
  isDate: ei,
  isFile: ti,
  isBlob: ni,
  isFunction: Ur,
  isStream: ri,
  isURLSearchParams: si,
  isStandardBrowserEnv: oi,
  forEach: kn,
  merge: mn,
  extend: ai,
  trim: ii,
  stripBOM: ui
}, Me = oe;
function Yn(n) {
  return encodeURIComponent(n).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
var Vr = function(e, t, r) {
  if (!t)
    return e;
  var s;
  if (r)
    s = r(t);
  else if (Me.isURLSearchParams(t))
    s = t.toString();
  else {
    var i = [];
    Me.forEach(t, function(f, a) {
      f === null || typeof f > "u" || (Me.isArray(f) ? a = a + "[]" : f = [f], Me.forEach(f, function(l) {
        Me.isDate(l) ? l = l.toISOString() : Me.isObject(l) && (l = JSON.stringify(l)), i.push(Yn(a) + "=" + Yn(l));
      }));
    }), s = i.join("&");
  }
  if (s) {
    var o = e.indexOf("#");
    o !== -1 && (e = e.slice(0, o)), e += (e.indexOf("?") === -1 ? "?" : "&") + s;
  }
  return e;
}, ci = oe;
function Lt() {
  this.handlers = [];
}
Lt.prototype.use = function(e, t, r) {
  return this.handlers.push({
    fulfilled: e,
    rejected: t,
    synchronous: r ? r.synchronous : !1,
    runWhen: r ? r.runWhen : null
  }), this.handlers.length - 1;
};
Lt.prototype.eject = function(e) {
  this.handlers[e] && (this.handlers[e] = null);
};
Lt.prototype.forEach = function(e) {
  ci.forEach(this.handlers, function(r) {
    r !== null && e(r);
  });
};
var li = Lt, fi = oe, hi = function(e, t) {
  fi.forEach(e, function(s, i) {
    i !== t && i.toUpperCase() === t.toUpperCase() && (e[t] = s, delete e[i]);
  });
}, jr = function(e, t, r, s, i) {
  return e.config = t, r && (e.code = r), e.request = s, e.response = i, e.isAxiosError = !0, e.toJSON = function() {
    return {
      message: this.message,
      name: this.name,
      description: this.description,
      number: this.number,
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      config: this.config,
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }, e;
}, $r = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, Wt, Jn;
function Mr() {
  if (Jn)
    return Wt;
  Jn = 1;
  var n = jr;
  return Wt = function(t, r, s, i, o) {
    var c = new Error(t);
    return n(c, r, s, i, o);
  }, Wt;
}
var Ht, zn;
function di() {
  if (zn)
    return Ht;
  zn = 1;
  var n = Mr();
  return Ht = function(t, r, s) {
    var i = s.config.validateStatus;
    !s.status || !i || i(s.status) ? t(s) : r(n(
      "Request failed with status code " + s.status,
      s.config,
      null,
      s.request,
      s
    ));
  }, Ht;
}
var Yt, Kn;
function pi() {
  if (Kn)
    return Yt;
  Kn = 1;
  var n = oe;
  return Yt = n.isStandardBrowserEnv() ? function() {
    return {
      write: function(r, s, i, o, c, f) {
        var a = [];
        a.push(r + "=" + encodeURIComponent(s)), n.isNumber(i) && a.push("expires=" + new Date(i).toGMTString()), n.isString(o) && a.push("path=" + o), n.isString(c) && a.push("domain=" + c), f === !0 && a.push("secure"), document.cookie = a.join("; ");
      },
      read: function(r) {
        var s = document.cookie.match(new RegExp("(^|;\\s*)(" + r + ")=([^;]*)"));
        return s ? decodeURIComponent(s[3]) : null;
      },
      remove: function(r) {
        this.write(r, "", Date.now() - 864e5);
      }
    };
  }() : function() {
    return {
      write: function() {
      },
      read: function() {
        return null;
      },
      remove: function() {
      }
    };
  }(), Yt;
}
var Jt, Gn;
function vi() {
  return Gn || (Gn = 1, Jt = function(e) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
  }), Jt;
}
var zt, Xn;
function mi() {
  return Xn || (Xn = 1, zt = function(e, t) {
    return t ? e.replace(/\/+$/, "") + "/" + t.replace(/^\/+/, "") : e;
  }), zt;
}
var Kt, Qn;
function yi() {
  if (Qn)
    return Kt;
  Qn = 1;
  var n = vi(), e = mi();
  return Kt = function(r, s) {
    return r && !n(s) ? e(r, s) : s;
  }, Kt;
}
var Gt, Zn;
function gi() {
  if (Zn)
    return Gt;
  Zn = 1;
  var n = oe, e = [
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ];
  return Gt = function(r) {
    var s = {}, i, o, c;
    return r && n.forEach(r.split(`
`), function(a) {
      if (c = a.indexOf(":"), i = n.trim(a.substr(0, c)).toLowerCase(), o = n.trim(a.substr(c + 1)), i) {
        if (s[i] && e.indexOf(i) >= 0)
          return;
        i === "set-cookie" ? s[i] = (s[i] ? s[i] : []).concat([o]) : s[i] = s[i] ? s[i] + ", " + o : o;
      }
    }), s;
  }, Gt;
}
var Xt, er;
function _i() {
  if (er)
    return Xt;
  er = 1;
  var n = oe;
  return Xt = n.isStandardBrowserEnv() ? function() {
    var t = /(msie|trident)/i.test(navigator.userAgent), r = document.createElement("a"), s;
    function i(o) {
      var c = o;
      return t && (r.setAttribute("href", c), c = r.href), r.setAttribute("href", c), {
        href: r.href,
        protocol: r.protocol ? r.protocol.replace(/:$/, "") : "",
        host: r.host,
        search: r.search ? r.search.replace(/^\?/, "") : "",
        hash: r.hash ? r.hash.replace(/^#/, "") : "",
        hostname: r.hostname,
        port: r.port,
        pathname: r.pathname.charAt(0) === "/" ? r.pathname : "/" + r.pathname
      };
    }
    return s = i(window.location.href), function(c) {
      var f = n.isString(c) ? i(c) : c;
      return f.protocol === s.protocol && f.host === s.host;
    };
  }() : function() {
    return function() {
      return !0;
    };
  }(), Xt;
}
var Qt, tr;
function Nt() {
  if (tr)
    return Qt;
  tr = 1;
  function n(e) {
    this.message = e;
  }
  return n.prototype.toString = function() {
    return "Cancel" + (this.message ? ": " + this.message : "");
  }, n.prototype.__CANCEL__ = !0, Qt = n, Qt;
}
var Zt, nr;
function rr() {
  if (nr)
    return Zt;
  nr = 1;
  var n = oe, e = di(), t = pi(), r = Vr, s = yi(), i = gi(), o = _i(), c = Mr(), f = $r, a = Nt();
  return Zt = function(l) {
    return new Promise(function(p, b) {
      var w = l.data, g = l.headers, L = l.responseType, R;
      function A() {
        l.cancelToken && l.cancelToken.unsubscribe(R), l.signal && l.signal.removeEventListener("abort", R);
      }
      n.isFormData(w) && delete g["Content-Type"];
      var m = new XMLHttpRequest();
      if (l.auth) {
        var $ = l.auth.username || "", E = l.auth.password ? unescape(encodeURIComponent(l.auth.password)) : "";
        g.Authorization = "Basic " + btoa($ + ":" + E);
      }
      var S = s(l.baseURL, l.url);
      m.open(l.method.toUpperCase(), r(S, l.params, l.paramsSerializer), !0), m.timeout = l.timeout;
      function K() {
        if (!!m) {
          var B = "getAllResponseHeaders" in m ? i(m.getAllResponseHeaders()) : null, re = !L || L === "text" || L === "json" ? m.responseText : m.response, Z = {
            data: re,
            status: m.status,
            statusText: m.statusText,
            headers: B,
            config: l,
            request: m
          };
          e(function(ee) {
            p(ee), A();
          }, function(ee) {
            b(ee), A();
          }, Z), m = null;
        }
      }
      if ("onloadend" in m ? m.onloadend = K : m.onreadystatechange = function() {
        !m || m.readyState !== 4 || m.status === 0 && !(m.responseURL && m.responseURL.indexOf("file:") === 0) || setTimeout(K);
      }, m.onabort = function() {
        !m || (b(c("Request aborted", l, "ECONNABORTED", m)), m = null);
      }, m.onerror = function() {
        b(c("Network Error", l, null, m)), m = null;
      }, m.ontimeout = function() {
        var re = l.timeout ? "timeout of " + l.timeout + "ms exceeded" : "timeout exceeded", Z = l.transitional || f;
        l.timeoutErrorMessage && (re = l.timeoutErrorMessage), b(c(
          re,
          l,
          Z.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
          m
        )), m = null;
      }, n.isStandardBrowserEnv()) {
        var N = (l.withCredentials || o(S)) && l.xsrfCookieName ? t.read(l.xsrfCookieName) : void 0;
        N && (g[l.xsrfHeaderName] = N);
      }
      "setRequestHeader" in m && n.forEach(g, function(re, Z) {
        typeof w > "u" && Z.toLowerCase() === "content-type" ? delete g[Z] : m.setRequestHeader(Z, re);
      }), n.isUndefined(l.withCredentials) || (m.withCredentials = !!l.withCredentials), L && L !== "json" && (m.responseType = l.responseType), typeof l.onDownloadProgress == "function" && m.addEventListener("progress", l.onDownloadProgress), typeof l.onUploadProgress == "function" && m.upload && m.upload.addEventListener("progress", l.onUploadProgress), (l.cancelToken || l.signal) && (R = function(B) {
        !m || (b(!B || B && B.type ? new a("canceled") : B), m.abort(), m = null);
      }, l.cancelToken && l.cancelToken.subscribe(R), l.signal && (l.signal.aborted ? R() : l.signal.addEventListener("abort", R))), w || (w = null), m.send(w);
    });
  }, Zt;
}
var G = oe, sr = hi, bi = jr, wi = $r, Ei = {
  "Content-Type": "application/x-www-form-urlencoded"
};
function ir(n, e) {
  !G.isUndefined(n) && G.isUndefined(n["Content-Type"]) && (n["Content-Type"] = e);
}
function Ri() {
  var n;
  return (typeof XMLHttpRequest < "u" || typeof process < "u" && Object.prototype.toString.call(process) === "[object process]") && (n = rr()), n;
}
function Si(n, e, t) {
  if (G.isString(n))
    try {
      return (e || JSON.parse)(n), G.trim(n);
    } catch (r) {
      if (r.name !== "SyntaxError")
        throw r;
    }
  return (t || JSON.stringify)(n);
}
var Pt = {
  transitional: wi,
  adapter: Ri(),
  transformRequest: [function(e, t) {
    return sr(t, "Accept"), sr(t, "Content-Type"), G.isFormData(e) || G.isArrayBuffer(e) || G.isBuffer(e) || G.isStream(e) || G.isFile(e) || G.isBlob(e) ? e : G.isArrayBufferView(e) ? e.buffer : G.isURLSearchParams(e) ? (ir(t, "application/x-www-form-urlencoded;charset=utf-8"), e.toString()) : G.isObject(e) || t && t["Content-Type"] === "application/json" ? (ir(t, "application/json"), Si(e)) : e;
  }],
  transformResponse: [function(e) {
    var t = this.transitional || Pt.transitional, r = t && t.silentJSONParsing, s = t && t.forcedJSONParsing, i = !r && this.responseType === "json";
    if (i || s && G.isString(e) && e.length)
      try {
        return JSON.parse(e);
      } catch (o) {
        if (i)
          throw o.name === "SyntaxError" ? bi(o, this, "E_JSON_PARSE") : o;
      }
    return e;
  }],
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  validateStatus: function(e) {
    return e >= 200 && e < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*"
    }
  }
};
G.forEach(["delete", "get", "head"], function(e) {
  Pt.headers[e] = {};
});
G.forEach(["post", "put", "patch"], function(e) {
  Pt.headers[e] = G.merge(Ei);
});
var Dn = Pt, Ti = oe, Oi = Dn, xi = function(e, t, r) {
  var s = this || Oi;
  return Ti.forEach(r, function(o) {
    e = o.call(s, e, t);
  }), e;
}, en, or;
function Wr() {
  return or || (or = 1, en = function(e) {
    return !!(e && e.__CANCEL__);
  }), en;
}
var ar = oe, tn = xi, Ci = Wr(), Ai = Dn, ki = Nt();
function nn(n) {
  if (n.cancelToken && n.cancelToken.throwIfRequested(), n.signal && n.signal.aborted)
    throw new ki("canceled");
}
var Di = function(e) {
  nn(e), e.headers = e.headers || {}, e.data = tn.call(
    e,
    e.data,
    e.headers,
    e.transformRequest
  ), e.headers = ar.merge(
    e.headers.common || {},
    e.headers[e.method] || {},
    e.headers
  ), ar.forEach(
    ["delete", "get", "head", "post", "put", "patch", "common"],
    function(s) {
      delete e.headers[s];
    }
  );
  var t = e.adapter || Ai.adapter;
  return t(e).then(function(s) {
    return nn(e), s.data = tn.call(
      e,
      s.data,
      s.headers,
      e.transformResponse
    ), s;
  }, function(s) {
    return Ci(s) || (nn(e), s && s.response && (s.response.data = tn.call(
      e,
      s.response.data,
      s.response.headers,
      e.transformResponse
    ))), Promise.reject(s);
  });
}, ae = oe, Hr = function(e, t) {
  t = t || {};
  var r = {};
  function s(h, l) {
    return ae.isPlainObject(h) && ae.isPlainObject(l) ? ae.merge(h, l) : ae.isPlainObject(l) ? ae.merge({}, l) : ae.isArray(l) ? l.slice() : l;
  }
  function i(h) {
    if (ae.isUndefined(t[h])) {
      if (!ae.isUndefined(e[h]))
        return s(void 0, e[h]);
    } else
      return s(e[h], t[h]);
  }
  function o(h) {
    if (!ae.isUndefined(t[h]))
      return s(void 0, t[h]);
  }
  function c(h) {
    if (ae.isUndefined(t[h])) {
      if (!ae.isUndefined(e[h]))
        return s(void 0, e[h]);
    } else
      return s(void 0, t[h]);
  }
  function f(h) {
    if (h in t)
      return s(e[h], t[h]);
    if (h in e)
      return s(void 0, e[h]);
  }
  var a = {
    url: o,
    method: o,
    data: o,
    baseURL: c,
    transformRequest: c,
    transformResponse: c,
    paramsSerializer: c,
    timeout: c,
    timeoutMessage: c,
    withCredentials: c,
    adapter: c,
    responseType: c,
    xsrfCookieName: c,
    xsrfHeaderName: c,
    onUploadProgress: c,
    onDownloadProgress: c,
    decompress: c,
    maxContentLength: c,
    maxBodyLength: c,
    transport: c,
    httpAgent: c,
    httpsAgent: c,
    cancelToken: c,
    socketPath: c,
    responseEncoding: c,
    validateStatus: f
  };
  return ae.forEach(Object.keys(e).concat(Object.keys(t)), function(l) {
    var v = a[l] || i, p = v(l);
    ae.isUndefined(p) && v !== f || (r[l] = p);
  }), r;
}, rn, ur;
function Yr() {
  return ur || (ur = 1, rn = {
    version: "0.26.1"
  }), rn;
}
var Li = Yr().version, Ln = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(function(n, e) {
  Ln[n] = function(r) {
    return typeof r === n || "a" + (e < 1 ? "n " : " ") + n;
  };
});
var cr = {};
Ln.transitional = function(e, t, r) {
  function s(i, o) {
    return "[Axios v" + Li + "] Transitional option '" + i + "'" + o + (r ? ". " + r : "");
  }
  return function(i, o, c) {
    if (e === !1)
      throw new Error(s(o, " has been removed" + (t ? " in " + t : "")));
    return t && !cr[o] && (cr[o] = !0, console.warn(
      s(
        o,
        " has been deprecated since v" + t + " and will be removed in the near future"
      )
    )), e ? e(i, o, c) : !0;
  };
};
function Ni(n, e, t) {
  if (typeof n != "object")
    throw new TypeError("options must be an object");
  for (var r = Object.keys(n), s = r.length; s-- > 0; ) {
    var i = r[s], o = e[i];
    if (o) {
      var c = n[i], f = c === void 0 || o(c, i, n);
      if (f !== !0)
        throw new TypeError("option " + i + " must be " + f);
      continue;
    }
    if (t !== !0)
      throw Error("Unknown option " + i);
  }
}
var Pi = {
  assertOptions: Ni,
  validators: Ln
}, Jr = oe, Bi = Vr, lr = li, fr = Di, Bt = Hr, zr = Pi, We = zr.validators;
function ft(n) {
  this.defaults = n, this.interceptors = {
    request: new lr(),
    response: new lr()
  };
}
ft.prototype.request = function(e, t) {
  typeof e == "string" ? (t = t || {}, t.url = e) : t = e || {}, t = Bt(this.defaults, t), t.method ? t.method = t.method.toLowerCase() : this.defaults.method ? t.method = this.defaults.method.toLowerCase() : t.method = "get";
  var r = t.transitional;
  r !== void 0 && zr.assertOptions(r, {
    silentJSONParsing: We.transitional(We.boolean),
    forcedJSONParsing: We.transitional(We.boolean),
    clarifyTimeoutError: We.transitional(We.boolean)
  }, !1);
  var s = [], i = !0;
  this.interceptors.request.forEach(function(p) {
    typeof p.runWhen == "function" && p.runWhen(t) === !1 || (i = i && p.synchronous, s.unshift(p.fulfilled, p.rejected));
  });
  var o = [];
  this.interceptors.response.forEach(function(p) {
    o.push(p.fulfilled, p.rejected);
  });
  var c;
  if (!i) {
    var f = [fr, void 0];
    for (Array.prototype.unshift.apply(f, s), f = f.concat(o), c = Promise.resolve(t); f.length; )
      c = c.then(f.shift(), f.shift());
    return c;
  }
  for (var a = t; s.length; ) {
    var h = s.shift(), l = s.shift();
    try {
      a = h(a);
    } catch (v) {
      l(v);
      break;
    }
  }
  try {
    c = fr(a);
  } catch (v) {
    return Promise.reject(v);
  }
  for (; o.length; )
    c = c.then(o.shift(), o.shift());
  return c;
};
ft.prototype.getUri = function(e) {
  return e = Bt(this.defaults, e), Bi(e.url, e.params, e.paramsSerializer).replace(/^\?/, "");
};
Jr.forEach(["delete", "get", "head", "options"], function(e) {
  ft.prototype[e] = function(t, r) {
    return this.request(Bt(r || {}, {
      method: e,
      url: t,
      data: (r || {}).data
    }));
  };
});
Jr.forEach(["post", "put", "patch"], function(e) {
  ft.prototype[e] = function(t, r, s) {
    return this.request(Bt(s || {}, {
      method: e,
      url: t,
      data: r
    }));
  };
});
var Fi = ft, sn, hr;
function Ii() {
  if (hr)
    return sn;
  hr = 1;
  var n = Nt();
  function e(t) {
    if (typeof t != "function")
      throw new TypeError("executor must be a function.");
    var r;
    this.promise = new Promise(function(o) {
      r = o;
    });
    var s = this;
    this.promise.then(function(i) {
      if (!!s._listeners) {
        var o, c = s._listeners.length;
        for (o = 0; o < c; o++)
          s._listeners[o](i);
        s._listeners = null;
      }
    }), this.promise.then = function(i) {
      var o, c = new Promise(function(f) {
        s.subscribe(f), o = f;
      }).then(i);
      return c.cancel = function() {
        s.unsubscribe(o);
      }, c;
    }, t(function(o) {
      s.reason || (s.reason = new n(o), r(s.reason));
    });
  }
  return e.prototype.throwIfRequested = function() {
    if (this.reason)
      throw this.reason;
  }, e.prototype.subscribe = function(r) {
    if (this.reason) {
      r(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(r) : this._listeners = [r];
  }, e.prototype.unsubscribe = function(r) {
    if (!!this._listeners) {
      var s = this._listeners.indexOf(r);
      s !== -1 && this._listeners.splice(s, 1);
    }
  }, e.source = function() {
    var r, s = new e(function(o) {
      r = o;
    });
    return {
      token: s,
      cancel: r
    };
  }, sn = e, sn;
}
var on, dr;
function qi() {
  return dr || (dr = 1, on = function(e) {
    return function(r) {
      return e.apply(null, r);
    };
  }), on;
}
var an, pr;
function Ui() {
  if (pr)
    return an;
  pr = 1;
  var n = oe;
  return an = function(t) {
    return n.isObject(t) && t.isAxiosError === !0;
  }, an;
}
var vr = oe, Vi = Fr, xt = Fi, ji = Hr, $i = Dn;
function Kr(n) {
  var e = new xt(n), t = Vi(xt.prototype.request, e);
  return vr.extend(t, xt.prototype, e), vr.extend(t, e), t.create = function(s) {
    return Kr(ji(n, s));
  }, t;
}
var ye = Kr($i);
ye.Axios = xt;
ye.Cancel = Nt();
ye.CancelToken = Ii();
ye.isCancel = Wr();
ye.VERSION = Yr().version;
ye.all = function(e) {
  return Promise.all(e);
};
ye.spread = qi();
ye.isAxiosError = Ui();
Cn.exports = ye;
Cn.exports.default = ye;
(function(n) {
  n.exports = Cn.exports;
})(Br);
Object.defineProperty(He, "__esModule", { value: !0 });
He.getRequestHeaders = He.getAxiosClient = void 0;
var Mi = Br.exports;
function Wi(n, e, t, r) {
  return Mi.default.create({
    baseURL: n,
    headers: Gr(e, r, t),
    withCredentials: !0
  });
}
He.getAxiosClient = Wi;
function Gr(n, e, t) {
  n === void 0 && (n = !1);
  var r = {
    Accept: "application/json",
    "Content-Type": "application/json; charset=utf-8"
  };
  return n && e && t && (r.Authorization = "".concat(e, " ").concat(t())), typeof window < "u" && typeof document < "u" && (r["X-Frappe-Site-Name"] = window.location.hostname, window.csrf_token && window.csrf_token !== "{{ csrf_token }}" && (r["X-Frappe-CSRF-Token"] = window.csrf_token)), r;
}
He.getRequestHeaders = Gr;
var mr;
function Hi() {
  if (mr)
    return et;
  mr = 1, Object.defineProperty(et, "__esModule", { value: !0 }), et.FrappeApp = void 0;
  var n = Xr(), e = ut, t = ct, r = lt, s = He, i = function() {
    function o(c, f, a) {
      var h, l;
      this.url = c, this.name = a != null ? a : "FrappeApp", this.useToken = (h = f == null ? void 0 : f.useToken) !== null && h !== void 0 ? h : !1, this.token = f == null ? void 0 : f.token, this.tokenType = (l = f == null ? void 0 : f.type) !== null && l !== void 0 ? l : "Bearer", this.axios = (0, s.getAxiosClient)(this.url, this.useToken, this.token, this.tokenType);
    }
    return o.prototype.auth = function() {
      return new n.FrappeAuth(this.url, this.axios, this.useToken, this.token, this.tokenType);
    }, o.prototype.db = function() {
      return new t.FrappeDB(this.url, this.axios, this.useToken, this.token, this.tokenType);
    }, o.prototype.file = function() {
      return new r.FrappeFileUpload(this.url, this.axios, this.useToken, this.token, this.tokenType);
    }, o.prototype.call = function() {
      return new e.FrappeCall(this.url, this.axios, this.useToken, this.token, this.tokenType);
    }, o;
  }();
  return et.FrappeApp = i, et;
}
var Ft = {}, bt = I && I.__awaiter || function(n, e, t, r) {
  function s(i) {
    return i instanceof t ? i : new t(function(o) {
      o(i);
    });
  }
  return new (t || (t = Promise))(function(i, o) {
    function c(h) {
      try {
        a(r.next(h));
      } catch (l) {
        o(l);
      }
    }
    function f(h) {
      try {
        a(r.throw(h));
      } catch (l) {
        o(l);
      }
    }
    function a(h) {
      h.done ? i(h.value) : s(h.value).then(c, f);
    }
    a((r = r.apply(n, e || [])).next());
  });
}, wt = I && I.__generator || function(n, e) {
  var t = { label: 0, sent: function() {
    if (i[0] & 1)
      throw i[1];
    return i[1];
  }, trys: [], ops: [] }, r, s, i, o;
  return o = { next: c(0), throw: c(1), return: c(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function c(a) {
    return function(h) {
      return f([a, h]);
    };
  }
  function f(a) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; t; )
      try {
        if (r = 1, s && (i = a[0] & 2 ? s.return : a[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, a[1])).done)
          return i;
        switch (s = 0, i && (a = [a[0] & 2, i.value]), a[0]) {
          case 0:
          case 1:
            i = a;
            break;
          case 4:
            return t.label++, { value: a[1], done: !1 };
          case 5:
            t.label++, s = a[1], a = [0];
            continue;
          case 7:
            a = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (a[0] === 6 || a[0] === 2)) {
              t = 0;
              continue;
            }
            if (a[0] === 3 && (!i || a[1] > i[0] && a[1] < i[3])) {
              t.label = a[1];
              break;
            }
            if (a[0] === 6 && t.label < i[1]) {
              t.label = i[1], i = a;
              break;
            }
            if (i && t.label < i[2]) {
              t.label = i[2], t.ops.push(a);
              break;
            }
            i[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        a = e.call(n, t);
      } catch (h) {
        a = [6, h], s = 0;
      } finally {
        r = i = 0;
      }
    if (a[0] & 5)
      throw a[1];
    return { value: a[0] ? a[1] : void 0, done: !0 };
  }
};
Object.defineProperty(Ft, "__esModule", { value: !0 });
Ft.FrappeAuth = void 0;
var Yi = function() {
  function n(e, t, r, s, i) {
    this.appURL = e, this.axios = t, this.useToken = r != null ? r : !1, this.token = s, this.tokenType = i;
  }
  return n.prototype.loginWithUsernamePassword = function(e) {
    return bt(this, void 0, void 0, function() {
      var t, r, s;
      return wt(this, function(i) {
        return t = e.username, r = e.password, s = e.device, [2, this.axios.post("/api/method/login", {
          usr: t,
          pwd: r,
          device: s
        }).then(function(o) {
          return o.data;
        }).catch(function(o) {
          var c, f;
          throw {
            httpStatus: o.response.status,
            httpStatusText: o.response.statusText,
            message: (c = o.response.data.message) !== null && c !== void 0 ? c : "There was an error while logging in",
            exception: (f = o.response.data.exception) !== null && f !== void 0 ? f : ""
          };
        })];
      });
    });
  }, n.prototype.getLoggedInUser = function() {
    return bt(this, void 0, void 0, function() {
      return wt(this, function(e) {
        return [2, this.axios.get("/api/method/frappe.auth.get_logged_user").then(function(t) {
          return t.data.message;
        }).catch(function(t) {
          var r;
          throw {
            httpStatus: t.response.status,
            httpStatusText: t.response.statusText,
            message: "There was an error while fetching the logged in user",
            exception: (r = t.response.data.exception) !== null && r !== void 0 ? r : ""
          };
        })];
      });
    });
  }, n.prototype.logout = function() {
    return bt(this, void 0, void 0, function() {
      return wt(this, function(e) {
        return [2, this.axios.post("/api/method/logout", {}).then(function() {
        }).catch(function(t) {
          var r, s;
          throw {
            httpStatus: t.response.status,
            httpStatusText: t.response.statusText,
            message: (r = t.response.data.message) !== null && r !== void 0 ? r : "There was an error while logging out",
            exception: (s = t.response.data.exception) !== null && s !== void 0 ? s : ""
          };
        })];
      });
    });
  }, n.prototype.forgetPassword = function(e) {
    return bt(this, void 0, void 0, function() {
      return wt(this, function(t) {
        return [2, this.axios.post("/", {
          cmd: "frappe.core.doctype.user.user.reset_password",
          user: e
        }).then(function() {
        }).catch(function(r) {
          var s, i;
          throw {
            httpStatus: r.response.status,
            httpStatusText: r.response.statusText,
            message: (s = r.response.data.message) !== null && s !== void 0 ? s : "There was an error sending password reset email.",
            exception: (i = r.response.data.exception) !== null && i !== void 0 ? i : ""
          };
        })];
      });
    });
  }, n;
}();
Ft.FrappeAuth = Yi;
var yr;
function Xr() {
  return yr || (yr = 1, function(n) {
    var e = I && I.__createBinding || (Object.create ? function(r, s, i, o) {
      o === void 0 && (o = i);
      var c = Object.getOwnPropertyDescriptor(s, i);
      (!c || ("get" in c ? !s.__esModule : c.writable || c.configurable)) && (c = { enumerable: !0, get: function() {
        return s[i];
      } }), Object.defineProperty(r, o, c);
    } : function(r, s, i, o) {
      o === void 0 && (o = i), r[o] = s[i];
    }), t = I && I.__exportStar || function(r, s) {
      for (var i in r)
        i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, r, i);
    };
    Object.defineProperty(n, "__esModule", { value: !0 }), t(Hi(), n), t(Ft, n), t(ct, n), t(lt, n), t(ut, n);
  }(Mt)), Mt;
}
var Ji = Xr(), Qr = { exports: {} }, un = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var gr;
function zi() {
  if (gr)
    return un;
  gr = 1;
  var n = Ye;
  function e(l, v) {
    return l === v && (l !== 0 || 1 / l === 1 / v) || l !== l && v !== v;
  }
  var t = typeof Object.is == "function" ? Object.is : e, r = n.useState, s = n.useEffect, i = n.useLayoutEffect, o = n.useDebugValue;
  function c(l, v) {
    var p = v(), b = r({ inst: { value: p, getSnapshot: v } }), w = b[0].inst, g = b[1];
    return i(function() {
      w.value = p, w.getSnapshot = v, f(w) && g({ inst: w });
    }, [l, p, v]), s(function() {
      return f(w) && g({ inst: w }), l(function() {
        f(w) && g({ inst: w });
      });
    }, [l]), o(p), p;
  }
  function f(l) {
    var v = l.getSnapshot;
    l = l.value;
    try {
      var p = v();
      return !t(l, p);
    } catch {
      return !0;
    }
  }
  function a(l, v) {
    return v();
  }
  var h = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? a : c;
  return un.useSyncExternalStore = n.useSyncExternalStore !== void 0 ? n.useSyncExternalStore : h, un;
}
var cn = {};
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var _r;
function Ki() {
  return _r || (_r = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var n = Ye, e = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function t(A) {
      {
        for (var m = arguments.length, $ = new Array(m > 1 ? m - 1 : 0), E = 1; E < m; E++)
          $[E - 1] = arguments[E];
        r("error", A, $);
      }
    }
    function r(A, m, $) {
      {
        var E = e.ReactDebugCurrentFrame, S = E.getStackAddendum();
        S !== "" && (m += "%s", $ = $.concat([S]));
        var K = $.map(function(N) {
          return String(N);
        });
        K.unshift("Warning: " + m), Function.prototype.apply.call(console[A], console, K);
      }
    }
    function s(A, m) {
      return A === m && (A !== 0 || 1 / A === 1 / m) || A !== A && m !== m;
    }
    var i = typeof Object.is == "function" ? Object.is : s, o = n.useState, c = n.useEffect, f = n.useLayoutEffect, a = n.useDebugValue, h = !1, l = !1;
    function v(A, m, $) {
      h || n.startTransition !== void 0 && (h = !0, t("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
      var E = m();
      if (!l) {
        var S = m();
        i(E, S) || (t("The result of getSnapshot should be cached to avoid an infinite loop"), l = !0);
      }
      var K = o({
        inst: {
          value: E,
          getSnapshot: m
        }
      }), N = K[0].inst, B = K[1];
      return f(function() {
        N.value = E, N.getSnapshot = m, p(N) && B({
          inst: N
        });
      }, [A, E, m]), c(function() {
        p(N) && B({
          inst: N
        });
        var re = function() {
          p(N) && B({
            inst: N
          });
        };
        return A(re);
      }, [A]), a(E), E;
    }
    function p(A) {
      var m = A.getSnapshot, $ = A.value;
      try {
        var E = m();
        return !i($, E);
      } catch {
        return !0;
      }
    }
    function b(A, m, $) {
      return m();
    }
    var w = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", g = !w, L = g ? b : v, R = n.useSyncExternalStore !== void 0 ? n.useSyncExternalStore : L;
    cn.useSyncExternalStore = R, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), cn;
}
(function(n) {
  process.env.NODE_ENV === "production" ? n.exports = zi() : n.exports = Ki();
})(Qr);
const Se = /* @__PURE__ */ new WeakMap(), ln = {}, Et = {}, Ce = () => {
}, pe = Ce(), fn = Object, k = (n) => n === pe, Te = (n) => typeof n == "function", Ae = (n, e) => ({
  ...n,
  ...e
}), Nn = "undefined", It = typeof window != Nn, yn = typeof document != Nn, Gi = () => It && typeof window.requestAnimationFrame != Nn, Zr = (n, e) => {
  const t = Se.get(n);
  return [
    () => !k(e) && n.get(e) || ln,
    (r) => {
      if (!k(e)) {
        const s = n.get(e);
        e in Et || (Et[e] = s), t[5](e, Ae(s, r), s || ln);
      }
    },
    t[6],
    () => !k(e) && e in Et ? Et[e] : !k(e) && n.get(e) || ln
  ];
}, Rt = /* @__PURE__ */ new WeakMap();
let Xi = 0;
const ot = (n) => {
  const e = typeof n, t = n && n.constructor, r = t == Date;
  let s, i;
  if (fn(n) === n && !r && t != RegExp) {
    if (s = Rt.get(n), s)
      return s;
    if (s = ++Xi + "~", Rt.set(n, s), t == Array) {
      for (s = "@", i = 0; i < n.length; i++)
        s += ot(n[i]) + ",";
      Rt.set(n, s);
    }
    if (t == fn) {
      s = "#";
      const o = fn.keys(n).sort();
      for (; !k(i = o.pop()); )
        k(n[i]) || (s += i + ":" + ot(n[i]) + ",");
      Rt.set(n, s);
    }
  } else
    s = r ? n.toJSON() : e == "symbol" ? n.toString() : e == "string" ? JSON.stringify(n) : "" + n;
  return s;
};
let gn = !0;
const Qi = () => gn, [_n, bn] = It && window.addEventListener ? [
  window.addEventListener.bind(window),
  window.removeEventListener.bind(window)
] : [
  Ce,
  Ce
], Zi = () => {
  const n = yn && document.visibilityState;
  return k(n) || n !== "hidden";
}, eo = (n) => (yn && document.addEventListener("visibilitychange", n), _n("focus", n), () => {
  yn && document.removeEventListener("visibilitychange", n), bn("focus", n);
}), to = (n) => {
  const e = () => {
    gn = !0, n();
  }, t = () => {
    gn = !1;
  };
  return _n("online", e), _n("offline", t), () => {
    bn("online", e), bn("offline", t);
  };
}, no = {
  isOnline: Qi,
  isVisible: Zi
}, ro = {
  initFocus: eo,
  initReconnect: to
}, br = !Ye.useId, at = !It || "Deno" in window, so = (n) => Gi() ? window.requestAnimationFrame(n) : setTimeout(n, 1), hn = at ? Je : js, dn = typeof navigator < "u" && navigator.connection, wr = !at && dn && ([
  "slow-2g",
  "2g"
].includes(dn.effectiveType) || dn.saveData), Pn = (n) => {
  if (Te(n))
    try {
      n = n();
    } catch {
      n = "";
    }
  const e = n;
  return n = typeof n == "string" ? n : (Array.isArray(n) ? n.length : n) ? ot(n) : "", [
    n,
    e
  ];
};
let io = 0;
const wn = () => ++io, es = 0, ts = 1, ns = 2, oo = 3;
var tt = {
  __proto__: null,
  ERROR_REVALIDATE_EVENT: oo,
  FOCUS_EVENT: es,
  MUTATE_EVENT: ns,
  RECONNECT_EVENT: ts
};
async function rs(...n) {
  const [e, t, r, s] = n, i = Ae({
    populateCache: !0,
    throwOnError: !0
  }, typeof s == "boolean" ? {
    revalidate: s
  } : s || {});
  let o = i.populateCache;
  const c = i.rollbackOnError;
  let f = i.optimisticData;
  const a = i.revalidate !== !1, h = (p) => typeof c == "function" ? c(p) : c !== !1, l = i.throwOnError;
  if (Te(t)) {
    const p = t, b = [], w = e.keys();
    for (let g = w.next(); !g.done; g = w.next()) {
      const L = g.value;
      !/^\$(inf|sub)\$/.test(L) && p(e.get(L)._k) && b.push(L);
    }
    return Promise.all(b.map(v));
  }
  return v(t);
  async function v(p) {
    const [b] = Pn(p);
    if (!b)
      return;
    const [w, g] = Zr(e, b), [L, R, A] = Se.get(e), m = L[b], $ = () => a && (delete A[b], m && m[0]) ? m[0](ns).then(() => w().data) : w().data;
    if (n.length < 3)
      return $();
    let E = r, S;
    const K = wn();
    R[b] = [
      K,
      0
    ];
    const N = !k(f), B = w(), re = B.data, Z = B._c, q = k(Z) ? re : Z;
    if (N && (f = Te(f) ? f(q) : f, g({
      data: f,
      _c: q
    })), Te(E))
      try {
        E = E(q);
      } catch (ue) {
        S = ue;
      }
    if (E && Te(E.then))
      if (E = await E.catch((ue) => {
        S = ue;
      }), K !== R[b][0]) {
        if (S)
          throw S;
        return E;
      } else
        S && N && h(S) && (o = !0, E = q, g({
          data: E,
          _c: pe
        }));
    o && (S || (Te(o) && (E = o(E, q)), g({
      data: E,
      _c: pe
    }))), R[b][1] = wn();
    const ee = await $();
    if (g({
      _c: pe
    }), S) {
      if (l)
        throw S;
      return;
    }
    return o ? ee : E;
  }
}
const Er = (n, e) => {
  for (const t in n)
    n[t][0] && n[t][0](e);
}, ao = (n, e) => {
  if (!Se.has(n)) {
    const t = Ae(ro, e), r = {}, s = rs.bind(pe, n);
    let i = Ce;
    const o = {}, c = (h, l) => {
      const v = o[h] || [];
      return o[h] = v, v.push(l), () => v.splice(v.indexOf(l), 1);
    }, f = (h, l, v) => {
      n.set(h, l);
      const p = o[h];
      if (p)
        for (const b of p)
          b(l, v);
    }, a = () => {
      if (!Se.has(n) && (Se.set(n, [
        r,
        {},
        {},
        {},
        s,
        f,
        c
      ]), !at)) {
        const h = t.initFocus(setTimeout.bind(pe, Er.bind(pe, r, es))), l = t.initReconnect(setTimeout.bind(pe, Er.bind(pe, r, ts)));
        i = () => {
          h && h(), l && l(), Se.delete(n);
        };
      }
    };
    return a(), [
      n,
      s,
      a,
      i
    ];
  }
  return [
    n,
    Se.get(n)[4]
  ];
}, uo = (n, e, t, r, s) => {
  const i = t.errorRetryCount, o = s.retryCount, c = ~~((Math.random() + 0.5) * (1 << (o < 8 ? o : 8))) * t.errorRetryInterval;
  !k(i) && o > i || setTimeout(r, c, s);
}, co = (n, e) => ot(n) == ot(e), [ss, lo] = ao(/* @__PURE__ */ new Map()), fo = Ae(
  {
    onLoadingSlow: Ce,
    onSuccess: Ce,
    onError: Ce,
    onErrorRetry: uo,
    onDiscarded: Ce,
    revalidateOnFocus: !0,
    revalidateOnReconnect: !0,
    revalidateIfStale: !0,
    shouldRetryOnError: !0,
    errorRetryInterval: wr ? 1e4 : 5e3,
    focusThrottleInterval: 5 * 1e3,
    dedupingInterval: 2 * 1e3,
    loadingTimeout: wr ? 5e3 : 3e3,
    compare: co,
    isPaused: () => !1,
    cache: ss,
    mutate: lo,
    fallback: {}
  },
  no
), ho = (n, e) => {
  const t = Ae(n, e);
  if (e) {
    const { use: r, fallback: s } = n, { use: i, fallback: o } = e;
    r && i && (t.use = r.concat(i)), s && o && (t.fallback = Ae(s, o));
  }
  return t;
}, po = Nr({}), is = It && window.__SWR_DEVTOOLS_USE__, vo = is ? window.__SWR_DEVTOOLS_USE__ : [], mo = () => {
  is && (window.__SWR_DEVTOOLS_REACT__ = Ye);
}, yo = (n) => Te(n[1]) ? [
  n[0],
  n[1],
  n[2] || {}
] : [
  n[0],
  null,
  (n[1] === null ? n[2] : n[1]) || {}
], go = () => Ae(fo, X(po)), _o = (n) => (e, t, r) => n(e, t && ((...i) => {
  const [o] = Pn(e), [, , , c] = Se.get(ss), f = c[o];
  return f ? (delete c[o], f) : t(...i);
}), r), bo = vo.concat(_o), wo = (n) => function(...t) {
  const r = go(), [s, i, o] = yo(t), c = ho(r, o);
  let f = n;
  const { use: a } = c, h = (a || []).concat(bo);
  for (let l = h.length; l--; )
    f = h[l](f);
  return f(s, i || c.fetcher || null, c);
}, Eo = (n, e, t) => {
  const r = e[n] || (e[n] = []);
  return r.push(t), () => {
    const s = r.indexOf(t);
    s >= 0 && (r[s] = r[r.length - 1], r.pop());
  };
};
mo();
const pn = {
  dedupe: !0
}, Ro = (n, e, t) => {
  const { cache: r, compare: s, suspense: i, fallbackData: o, revalidateOnMount: c, revalidateIfStale: f, refreshInterval: a, refreshWhenHidden: h, refreshWhenOffline: l, keepPreviousData: v } = t, [p, b, w] = Se.get(r), [g, L] = Pn(n), R = Ne(!1), A = Ne(!1), m = Ne(g), $ = Ne(e), E = Ne(t), S = () => E.current, K = () => S().isVisible() && S().isOnline(), [N, B, re, Z] = Zr(r, g), q = Ne({}).current, ee = k(o) ? t.fallback[g] : o, ue = (F, j) => {
    for (const J in q) {
      const U = J;
      if (U === "data") {
        if (!s(F[U], j[U]) && (!k(F[U]) || !s(Qe, j[U])))
          return !1;
      } else if (j[U] !== F[U])
        return !1;
    }
    return !0;
  }, Ke = Pr(() => {
    const F = (() => !g || !e ? !1 : k(c) ? S().isPaused() || i ? !1 : k(f) ? !0 : f : c)(), j = (z) => {
      const se = Ae(z);
      return delete se._k, F ? {
        isValidating: !0,
        isLoading: !0,
        ...se
      } : se;
    }, J = N(), U = Z(), te = j(J), fe = J === U ? te : j(U);
    let W = te;
    return [
      () => {
        const z = j(N());
        return ue(z, W) ? (W.data = z.data, W.isLoading = z.isLoading, W.isValidating = z.isValidating, W.error = z.error, W) : (W = z, z);
      },
      () => fe
    ];
  }, [
    r,
    g
  ]), ge = Qr.exports.useSyncExternalStore(V(
    (F) => re(g, (j, J) => {
      ue(J, j) || F();
    }),
    [
      r,
      g
    ]
  ), Ke[0], Ke[1]), Ge = !R.current, dt = p[g] && p[g].length > 0, _e = ge.data, be = k(_e) ? ee : _e, De = ge.error, Xe = Ne(be), Qe = v ? k(_e) ? Xe.current : _e : be, pt = (() => dt && !k(De) ? !1 : Ge && !k(c) ? c : S().isPaused() ? !1 : i ? k(be) ? !1 : f : k(be) || f)(), Fe = !!(g && e && Ge && pt), Ze = k(ge.isValidating) ? Fe : ge.isValidating, Ie = k(ge.isLoading) ? Fe : ge.isLoading, we = V(
    async (F) => {
      const j = $.current;
      if (!g || !j || A.current || S().isPaused())
        return !1;
      let J, U, te = !0;
      const fe = F || {}, W = !w[g] || !fe.dedupe, z = () => br ? !A.current && g === m.current && R.current : g === m.current, se = {
        isValidating: !1,
        isLoading: !1
      }, vt = () => {
        B(se);
      }, mt = () => {
        const ie = w[g];
        ie && ie[1] === U && delete w[g];
      }, Ue = {
        isValidating: !0
      };
      k(N().data) && (Ue.isLoading = !0);
      try {
        if (W && (B(Ue), t.loadingTimeout && k(N().data) && setTimeout(() => {
          te && z() && S().onLoadingSlow(g, t);
        }, t.loadingTimeout), w[g] = [
          j(L),
          wn()
        ]), [J, U] = w[g], J = await J, W && setTimeout(mt, t.dedupingInterval), !w[g] || w[g][1] !== U)
          return W && z() && S().onDiscarded(g), !1;
        se.error = pe;
        const ie = b[g];
        if (!k(ie) && (U <= ie[0] || U <= ie[1] || ie[1] === 0))
          return vt(), W && z() && S().onDiscarded(g), !1;
        const he = N().data;
        se.data = s(he, J) ? he : J, W && z() && S().onSuccess(J, g, t);
      } catch (ie) {
        mt();
        const he = S(), { shouldRetryOnError: Ve } = he;
        he.isPaused() || (se.error = ie, W && z() && (he.onError(ie, g, he), (Ve === !0 || Te(Ve) && Ve(ie)) && K() && he.onErrorRetry(ie, g, he, (yt) => {
          const Ee = p[g];
          Ee && Ee[0] && Ee[0](tt.ERROR_REVALIDATE_EVENT, yt);
        }, {
          retryCount: (fe.retryCount || 0) + 1,
          dedupe: !0
        })));
      }
      return te = !1, vt(), !0;
    },
    [
      g,
      r
    ]
  ), qe = V(
    (...F) => rs(r, m.current, ...F),
    []
  );
  if (hn(() => {
    $.current = e, E.current = t, k(_e) || (Xe.current = _e);
  }), hn(() => {
    if (!g)
      return;
    const F = we.bind(pe, pn);
    let j = 0;
    const U = Eo(g, p, (te, fe = {}) => {
      if (te == tt.FOCUS_EVENT) {
        const W = Date.now();
        S().revalidateOnFocus && W > j && K() && (j = W + S().focusThrottleInterval, F());
      } else if (te == tt.RECONNECT_EVENT)
        S().revalidateOnReconnect && K() && F();
      else {
        if (te == tt.MUTATE_EVENT)
          return we();
        if (te == tt.ERROR_REVALIDATE_EVENT)
          return we(fe);
      }
    });
    return A.current = !1, m.current = g, R.current = !0, B({
      _k: L
    }), pt && (k(be) || at ? F() : so(F)), () => {
      A.current = !0, U();
    };
  }, [
    g
  ]), hn(() => {
    let F;
    function j() {
      const U = Te(a) ? a(N().data) : a;
      U && F !== -1 && (F = setTimeout(J, U));
    }
    function J() {
      !N().error && (h || S().isVisible()) && (l || S().isOnline()) ? we(pn).then(j) : j();
    }
    return j(), () => {
      F && (clearTimeout(F), F = -1);
    };
  }, [
    a,
    h,
    l,
    g
  ]), $s(Qe), i && k(be) && g)
    throw !br && at ? new Error("Fallback data is required when using suspense in SSR.") : ($.current = e, E.current = t, A.current = !1, k(De) ? we(pn) : De);
  return {
    mutate: qe,
    get data() {
      return q.data = !0, Qe;
    },
    get error() {
      return q.error = !0, De;
    },
    get isValidating() {
      return q.isValidating = !0, Ze;
    },
    get isLoading() {
      return q.isLoading = !0, Ie;
    }
  };
}, ht = wo(Ro), me = /* @__PURE__ */ Object.create(null);
me.open = "0";
me.close = "1";
me.ping = "2";
me.pong = "3";
me.message = "4";
me.upgrade = "5";
me.noop = "6";
const Ct = /* @__PURE__ */ Object.create(null);
Object.keys(me).forEach((n) => {
  Ct[me[n]] = n;
});
const So = { type: "error", data: "parser error" }, To = typeof Blob == "function" || typeof Blob < "u" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]", Oo = typeof ArrayBuffer == "function", xo = (n) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(n) : n && n.buffer instanceof ArrayBuffer, os = ({ type: n, data: e }, t, r) => To && e instanceof Blob ? t ? r(e) : Rr(e, r) : Oo && (e instanceof ArrayBuffer || xo(e)) ? t ? r(e) : Rr(new Blob([e]), r) : r(me[n] + (e || "")), Rr = (n, e) => {
  const t = new FileReader();
  return t.onload = function() {
    const r = t.result.split(",")[1];
    e("b" + (r || ""));
  }, t.readAsDataURL(n);
}, Sr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", it = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (let n = 0; n < Sr.length; n++)
  it[Sr.charCodeAt(n)] = n;
const Co = (n) => {
  let e = n.length * 0.75, t = n.length, r, s = 0, i, o, c, f;
  n[n.length - 1] === "=" && (e--, n[n.length - 2] === "=" && e--);
  const a = new ArrayBuffer(e), h = new Uint8Array(a);
  for (r = 0; r < t; r += 4)
    i = it[n.charCodeAt(r)], o = it[n.charCodeAt(r + 1)], c = it[n.charCodeAt(r + 2)], f = it[n.charCodeAt(r + 3)], h[s++] = i << 2 | o >> 4, h[s++] = (o & 15) << 4 | c >> 2, h[s++] = (c & 3) << 6 | f & 63;
  return a;
}, Ao = typeof ArrayBuffer == "function", as = (n, e) => {
  if (typeof n != "string")
    return {
      type: "message",
      data: us(n, e)
    };
  const t = n.charAt(0);
  return t === "b" ? {
    type: "message",
    data: ko(n.substring(1), e)
  } : Ct[t] ? n.length > 1 ? {
    type: Ct[t],
    data: n.substring(1)
  } : {
    type: Ct[t]
  } : So;
}, ko = (n, e) => {
  if (Ao) {
    const t = Co(n);
    return us(t, e);
  } else
    return { base64: !0, data: n };
}, us = (n, e) => {
  switch (e) {
    case "blob":
      return n instanceof ArrayBuffer ? new Blob([n]) : n;
    case "arraybuffer":
    default:
      return n;
  }
}, cs = String.fromCharCode(30), Do = (n, e) => {
  const t = n.length, r = new Array(t);
  let s = 0;
  n.forEach((i, o) => {
    os(i, !1, (c) => {
      r[o] = c, ++s === t && e(r.join(cs));
    });
  });
}, Lo = (n, e) => {
  const t = n.split(cs), r = [];
  for (let s = 0; s < t.length; s++) {
    const i = as(t[s], e);
    if (r.push(i), i.type === "error")
      break;
  }
  return r;
}, ls = 4;
function Y(n) {
  if (n)
    return No(n);
}
function No(n) {
  for (var e in Y.prototype)
    n[e] = Y.prototype[e];
  return n;
}
Y.prototype.on = Y.prototype.addEventListener = function(n, e) {
  return this._callbacks = this._callbacks || {}, (this._callbacks["$" + n] = this._callbacks["$" + n] || []).push(e), this;
};
Y.prototype.once = function(n, e) {
  function t() {
    this.off(n, t), e.apply(this, arguments);
  }
  return t.fn = e, this.on(n, t), this;
};
Y.prototype.off = Y.prototype.removeListener = Y.prototype.removeAllListeners = Y.prototype.removeEventListener = function(n, e) {
  if (this._callbacks = this._callbacks || {}, arguments.length == 0)
    return this._callbacks = {}, this;
  var t = this._callbacks["$" + n];
  if (!t)
    return this;
  if (arguments.length == 1)
    return delete this._callbacks["$" + n], this;
  for (var r, s = 0; s < t.length; s++)
    if (r = t[s], r === e || r.fn === e) {
      t.splice(s, 1);
      break;
    }
  return t.length === 0 && delete this._callbacks["$" + n], this;
};
Y.prototype.emit = function(n) {
  this._callbacks = this._callbacks || {};
  for (var e = new Array(arguments.length - 1), t = this._callbacks["$" + n], r = 1; r < arguments.length; r++)
    e[r - 1] = arguments[r];
  if (t) {
    t = t.slice(0);
    for (var r = 0, s = t.length; r < s; ++r)
      t[r].apply(this, e);
  }
  return this;
};
Y.prototype.emitReserved = Y.prototype.emit;
Y.prototype.listeners = function(n) {
  return this._callbacks = this._callbacks || {}, this._callbacks["$" + n] || [];
};
Y.prototype.hasListeners = function(n) {
  return !!this.listeners(n).length;
};
const le = (() => typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")())();
function fs(n, ...e) {
  return e.reduce((t, r) => (n.hasOwnProperty(r) && (t[r] = n[r]), t), {});
}
const Po = le.setTimeout, Bo = le.clearTimeout;
function qt(n, e) {
  e.useNativeTimers ? (n.setTimeoutFn = Po.bind(le), n.clearTimeoutFn = Bo.bind(le)) : (n.setTimeoutFn = le.setTimeout.bind(le), n.clearTimeoutFn = le.clearTimeout.bind(le));
}
const Fo = 1.33;
function Io(n) {
  return typeof n == "string" ? qo(n) : Math.ceil((n.byteLength || n.size) * Fo);
}
function qo(n) {
  let e = 0, t = 0;
  for (let r = 0, s = n.length; r < s; r++)
    e = n.charCodeAt(r), e < 128 ? t += 1 : e < 2048 ? t += 2 : e < 55296 || e >= 57344 ? t += 3 : (r++, t += 4);
  return t;
}
class Uo extends Error {
  constructor(e, t, r) {
    super(e), this.description = t, this.context = r, this.type = "TransportError";
  }
}
class hs extends Y {
  constructor(e) {
    super(), this.writable = !1, qt(this, e), this.opts = e, this.query = e.query, this.socket = e.socket;
  }
  onError(e, t, r) {
    return super.emitReserved("error", new Uo(e, t, r)), this;
  }
  open() {
    return this.readyState = "opening", this.doOpen(), this;
  }
  close() {
    return (this.readyState === "opening" || this.readyState === "open") && (this.doClose(), this.onClose()), this;
  }
  send(e) {
    this.readyState === "open" && this.write(e);
  }
  onOpen() {
    this.readyState = "open", this.writable = !0, super.emitReserved("open");
  }
  onData(e) {
    const t = as(e, this.socket.binaryType);
    this.onPacket(t);
  }
  onPacket(e) {
    super.emitReserved("packet", e);
  }
  onClose(e) {
    this.readyState = "closed", super.emitReserved("close", e);
  }
  pause(e) {
  }
}
const ds = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""), En = 64, Vo = {};
let Tr = 0, St = 0, Or;
function xr(n) {
  let e = "";
  do
    e = ds[n % En] + e, n = Math.floor(n / En);
  while (n > 0);
  return e;
}
function ps() {
  const n = xr(+new Date());
  return n !== Or ? (Tr = 0, Or = n) : n + "." + xr(Tr++);
}
for (; St < En; St++)
  Vo[ds[St]] = St;
function vs(n) {
  let e = "";
  for (let t in n)
    n.hasOwnProperty(t) && (e.length && (e += "&"), e += encodeURIComponent(t) + "=" + encodeURIComponent(n[t]));
  return e;
}
function jo(n) {
  let e = {}, t = n.split("&");
  for (let r = 0, s = t.length; r < s; r++) {
    let i = t[r].split("=");
    e[decodeURIComponent(i[0])] = decodeURIComponent(i[1]);
  }
  return e;
}
let ms = !1;
try {
  ms = typeof XMLHttpRequest < "u" && "withCredentials" in new XMLHttpRequest();
} catch {
}
const $o = ms;
function ys(n) {
  const e = n.xdomain;
  try {
    if (typeof XMLHttpRequest < "u" && (!e || $o))
      return new XMLHttpRequest();
  } catch {
  }
  if (!e)
    try {
      return new le[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch {
    }
}
function Mo() {
}
const Wo = function() {
  return new ys({
    xdomain: !1
  }).responseType != null;
}();
class Ho extends hs {
  constructor(e) {
    if (super(e), this.polling = !1, typeof location < "u") {
      const r = location.protocol === "https:";
      let s = location.port;
      s || (s = r ? "443" : "80"), this.xd = typeof location < "u" && e.hostname !== location.hostname || s !== e.port, this.xs = e.secure !== r;
    }
    const t = e && e.forceBase64;
    this.supportsBinary = Wo && !t;
  }
  get name() {
    return "polling";
  }
  doOpen() {
    this.poll();
  }
  pause(e) {
    this.readyState = "pausing";
    const t = () => {
      this.readyState = "paused", e();
    };
    if (this.polling || !this.writable) {
      let r = 0;
      this.polling && (r++, this.once("pollComplete", function() {
        --r || t();
      })), this.writable || (r++, this.once("drain", function() {
        --r || t();
      }));
    } else
      t();
  }
  poll() {
    this.polling = !0, this.doPoll(), this.emitReserved("poll");
  }
  onData(e) {
    const t = (r) => {
      if (this.readyState === "opening" && r.type === "open" && this.onOpen(), r.type === "close")
        return this.onClose({ description: "transport closed by the server" }), !1;
      this.onPacket(r);
    };
    Lo(e, this.socket.binaryType).forEach(t), this.readyState !== "closed" && (this.polling = !1, this.emitReserved("pollComplete"), this.readyState === "open" && this.poll());
  }
  doClose() {
    const e = () => {
      this.write([{ type: "close" }]);
    };
    this.readyState === "open" ? e() : this.once("open", e);
  }
  write(e) {
    this.writable = !1, Do(e, (t) => {
      this.doWrite(t, () => {
        this.writable = !0, this.emitReserved("drain");
      });
    });
  }
  uri() {
    let e = this.query || {};
    const t = this.opts.secure ? "https" : "http";
    let r = "";
    this.opts.timestampRequests !== !1 && (e[this.opts.timestampParam] = ps()), !this.supportsBinary && !e.sid && (e.b64 = 1), this.opts.port && (t === "https" && Number(this.opts.port) !== 443 || t === "http" && Number(this.opts.port) !== 80) && (r = ":" + this.opts.port);
    const s = vs(e), i = this.opts.hostname.indexOf(":") !== -1;
    return t + "://" + (i ? "[" + this.opts.hostname + "]" : this.opts.hostname) + r + this.opts.path + (s.length ? "?" + s : "");
  }
  request(e = {}) {
    return Object.assign(e, { xd: this.xd, xs: this.xs }, this.opts), new ve(this.uri(), e);
  }
  doWrite(e, t) {
    const r = this.request({
      method: "POST",
      data: e
    });
    r.on("success", t), r.on("error", (s, i) => {
      this.onError("xhr post error", s, i);
    });
  }
  doPoll() {
    const e = this.request();
    e.on("data", this.onData.bind(this)), e.on("error", (t, r) => {
      this.onError("xhr poll error", t, r);
    }), this.pollXhr = e;
  }
}
class ve extends Y {
  constructor(e, t) {
    super(), qt(this, t), this.opts = t, this.method = t.method || "GET", this.uri = e, this.async = t.async !== !1, this.data = t.data !== void 0 ? t.data : null, this.create();
  }
  create() {
    const e = fs(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
    e.xdomain = !!this.opts.xd, e.xscheme = !!this.opts.xs;
    const t = this.xhr = new ys(e);
    try {
      t.open(this.method, this.uri, this.async);
      try {
        if (this.opts.extraHeaders) {
          t.setDisableHeaderCheck && t.setDisableHeaderCheck(!0);
          for (let r in this.opts.extraHeaders)
            this.opts.extraHeaders.hasOwnProperty(r) && t.setRequestHeader(r, this.opts.extraHeaders[r]);
        }
      } catch {
      }
      if (this.method === "POST")
        try {
          t.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch {
        }
      try {
        t.setRequestHeader("Accept", "*/*");
      } catch {
      }
      "withCredentials" in t && (t.withCredentials = this.opts.withCredentials), this.opts.requestTimeout && (t.timeout = this.opts.requestTimeout), t.onreadystatechange = () => {
        t.readyState === 4 && (t.status === 200 || t.status === 1223 ? this.onLoad() : this.setTimeoutFn(() => {
          this.onError(typeof t.status == "number" ? t.status : 0);
        }, 0));
      }, t.send(this.data);
    } catch (r) {
      this.setTimeoutFn(() => {
        this.onError(r);
      }, 0);
      return;
    }
    typeof document < "u" && (this.index = ve.requestsCount++, ve.requests[this.index] = this);
  }
  onError(e) {
    this.emitReserved("error", e, this.xhr), this.cleanup(!0);
  }
  cleanup(e) {
    if (!(typeof this.xhr > "u" || this.xhr === null)) {
      if (this.xhr.onreadystatechange = Mo, e)
        try {
          this.xhr.abort();
        } catch {
        }
      typeof document < "u" && delete ve.requests[this.index], this.xhr = null;
    }
  }
  onLoad() {
    const e = this.xhr.responseText;
    e !== null && (this.emitReserved("data", e), this.emitReserved("success"), this.cleanup());
  }
  abort() {
    this.cleanup();
  }
}
ve.requestsCount = 0;
ve.requests = {};
if (typeof document < "u") {
  if (typeof attachEvent == "function")
    attachEvent("onunload", Cr);
  else if (typeof addEventListener == "function") {
    const n = "onpagehide" in le ? "pagehide" : "unload";
    addEventListener(n, Cr, !1);
  }
}
function Cr() {
  for (let n in ve.requests)
    ve.requests.hasOwnProperty(n) && ve.requests[n].abort();
}
const gs = (() => typeof Promise == "function" && typeof Promise.resolve == "function" ? (e) => Promise.resolve().then(e) : (e, t) => t(e, 0))(), Tt = le.WebSocket || le.MozWebSocket, Ar = !0, Yo = "arraybuffer", kr = typeof navigator < "u" && typeof navigator.product == "string" && navigator.product.toLowerCase() === "reactnative";
class Jo extends hs {
  constructor(e) {
    super(e), this.supportsBinary = !e.forceBase64;
  }
  get name() {
    return "websocket";
  }
  doOpen() {
    if (!this.check())
      return;
    const e = this.uri(), t = this.opts.protocols, r = kr ? {} : fs(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    this.opts.extraHeaders && (r.headers = this.opts.extraHeaders);
    try {
      this.ws = Ar && !kr ? t ? new Tt(e, t) : new Tt(e) : new Tt(e, t, r);
    } catch (s) {
      return this.emitReserved("error", s);
    }
    this.ws.binaryType = this.socket.binaryType || Yo, this.addEventListeners();
  }
  addEventListeners() {
    this.ws.onopen = () => {
      this.opts.autoUnref && this.ws._socket.unref(), this.onOpen();
    }, this.ws.onclose = (e) => this.onClose({
      description: "websocket connection closed",
      context: e
    }), this.ws.onmessage = (e) => this.onData(e.data), this.ws.onerror = (e) => this.onError("websocket error", e);
  }
  write(e) {
    this.writable = !1;
    for (let t = 0; t < e.length; t++) {
      const r = e[t], s = t === e.length - 1;
      os(r, this.supportsBinary, (i) => {
        const o = {};
        try {
          Ar && this.ws.send(i);
        } catch {
        }
        s && gs(() => {
          this.writable = !0, this.emitReserved("drain");
        }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    typeof this.ws < "u" && (this.ws.close(), this.ws = null);
  }
  uri() {
    let e = this.query || {};
    const t = this.opts.secure ? "wss" : "ws";
    let r = "";
    this.opts.port && (t === "wss" && Number(this.opts.port) !== 443 || t === "ws" && Number(this.opts.port) !== 80) && (r = ":" + this.opts.port), this.opts.timestampRequests && (e[this.opts.timestampParam] = ps()), this.supportsBinary || (e.b64 = 1);
    const s = vs(e), i = this.opts.hostname.indexOf(":") !== -1;
    return t + "://" + (i ? "[" + this.opts.hostname + "]" : this.opts.hostname) + r + this.opts.path + (s.length ? "?" + s : "");
  }
  check() {
    return !!Tt;
  }
}
const zo = {
  websocket: Jo,
  polling: Ho
}, Ko = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, Go = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
function Rn(n) {
  const e = n, t = n.indexOf("["), r = n.indexOf("]");
  t != -1 && r != -1 && (n = n.substring(0, t) + n.substring(t, r).replace(/:/g, ";") + n.substring(r, n.length));
  let s = Ko.exec(n || ""), i = {}, o = 14;
  for (; o--; )
    i[Go[o]] = s[o] || "";
  return t != -1 && r != -1 && (i.source = e, i.host = i.host.substring(1, i.host.length - 1).replace(/;/g, ":"), i.authority = i.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), i.ipv6uri = !0), i.pathNames = Xo(i, i.path), i.queryKey = Qo(i, i.query), i;
}
function Xo(n, e) {
  const t = /\/{2,9}/g, r = e.replace(t, "/").split("/");
  return (e.slice(0, 1) == "/" || e.length === 0) && r.splice(0, 1), e.slice(-1) == "/" && r.splice(r.length - 1, 1), r;
}
function Qo(n, e) {
  const t = {};
  return e.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function(r, s, i) {
    s && (t[s] = i);
  }), t;
}
class xe extends Y {
  constructor(e, t = {}) {
    super(), this.writeBuffer = [], e && typeof e == "object" && (t = e, e = null), e ? (e = Rn(e), t.hostname = e.host, t.secure = e.protocol === "https" || e.protocol === "wss", t.port = e.port, e.query && (t.query = e.query)) : t.host && (t.hostname = Rn(t.host).host), qt(this, t), this.secure = t.secure != null ? t.secure : typeof location < "u" && location.protocol === "https:", t.hostname && !t.port && (t.port = this.secure ? "443" : "80"), this.hostname = t.hostname || (typeof location < "u" ? location.hostname : "localhost"), this.port = t.port || (typeof location < "u" && location.port ? location.port : this.secure ? "443" : "80"), this.transports = t.transports || ["polling", "websocket"], this.writeBuffer = [], this.prevBufferLen = 0, this.opts = Object.assign({
      path: "/engine.io",
      agent: !1,
      withCredentials: !1,
      upgrade: !0,
      timestampParam: "t",
      rememberUpgrade: !1,
      addTrailingSlash: !0,
      rejectUnauthorized: !0,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: !0
    }, t), this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : ""), typeof this.opts.query == "string" && (this.opts.query = jo(this.opts.query)), this.id = null, this.upgrades = null, this.pingInterval = null, this.pingTimeout = null, this.pingTimeoutTimer = null, typeof addEventListener == "function" && (this.opts.closeOnBeforeunload && (this.beforeunloadEventListener = () => {
      this.transport && (this.transport.removeAllListeners(), this.transport.close());
    }, addEventListener("beforeunload", this.beforeunloadEventListener, !1)), this.hostname !== "localhost" && (this.offlineEventListener = () => {
      this.onClose("transport close", {
        description: "network connection lost"
      });
    }, addEventListener("offline", this.offlineEventListener, !1))), this.open();
  }
  createTransport(e) {
    const t = Object.assign({}, this.opts.query);
    t.EIO = ls, t.transport = e, this.id && (t.sid = this.id);
    const r = Object.assign({}, this.opts.transportOptions[e], this.opts, {
      query: t,
      socket: this,
      hostname: this.hostname,
      secure: this.secure,
      port: this.port
    });
    return new zo[e](r);
  }
  open() {
    let e;
    if (this.opts.rememberUpgrade && xe.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1)
      e = "websocket";
    else if (this.transports.length === 0) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    } else
      e = this.transports[0];
    this.readyState = "opening";
    try {
      e = this.createTransport(e);
    } catch {
      this.transports.shift(), this.open();
      return;
    }
    e.open(), this.setTransport(e);
  }
  setTransport(e) {
    this.transport && this.transport.removeAllListeners(), this.transport = e, e.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", (t) => this.onClose("transport close", t));
  }
  probe(e) {
    let t = this.createTransport(e), r = !1;
    xe.priorWebsocketSuccess = !1;
    const s = () => {
      r || (t.send([{ type: "ping", data: "probe" }]), t.once("packet", (l) => {
        if (!r)
          if (l.type === "pong" && l.data === "probe") {
            if (this.upgrading = !0, this.emitReserved("upgrading", t), !t)
              return;
            xe.priorWebsocketSuccess = t.name === "websocket", this.transport.pause(() => {
              r || this.readyState !== "closed" && (h(), this.setTransport(t), t.send([{ type: "upgrade" }]), this.emitReserved("upgrade", t), t = null, this.upgrading = !1, this.flush());
            });
          } else {
            const v = new Error("probe error");
            v.transport = t.name, this.emitReserved("upgradeError", v);
          }
      }));
    };
    function i() {
      r || (r = !0, h(), t.close(), t = null);
    }
    const o = (l) => {
      const v = new Error("probe error: " + l);
      v.transport = t.name, i(), this.emitReserved("upgradeError", v);
    };
    function c() {
      o("transport closed");
    }
    function f() {
      o("socket closed");
    }
    function a(l) {
      t && l.name !== t.name && i();
    }
    const h = () => {
      t.removeListener("open", s), t.removeListener("error", o), t.removeListener("close", c), this.off("close", f), this.off("upgrading", a);
    };
    t.once("open", s), t.once("error", o), t.once("close", c), this.once("close", f), this.once("upgrading", a), t.open();
  }
  onOpen() {
    if (this.readyState = "open", xe.priorWebsocketSuccess = this.transport.name === "websocket", this.emitReserved("open"), this.flush(), this.readyState === "open" && this.opts.upgrade) {
      let e = 0;
      const t = this.upgrades.length;
      for (; e < t; e++)
        this.probe(this.upgrades[e]);
    }
  }
  onPacket(e) {
    if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing")
      switch (this.emitReserved("packet", e), this.emitReserved("heartbeat"), e.type) {
        case "open":
          this.onHandshake(JSON.parse(e.data));
          break;
        case "ping":
          this.resetPingTimeout(), this.sendPacket("pong"), this.emitReserved("ping"), this.emitReserved("pong");
          break;
        case "error":
          const t = new Error("server error");
          t.code = e.data, this.onError(t);
          break;
        case "message":
          this.emitReserved("data", e.data), this.emitReserved("message", e.data);
          break;
      }
  }
  onHandshake(e) {
    this.emitReserved("handshake", e), this.id = e.sid, this.transport.query.sid = e.sid, this.upgrades = this.filterUpgrades(e.upgrades), this.pingInterval = e.pingInterval, this.pingTimeout = e.pingTimeout, this.maxPayload = e.maxPayload, this.onOpen(), this.readyState !== "closed" && this.resetPingTimeout();
  }
  resetPingTimeout() {
    this.clearTimeoutFn(this.pingTimeoutTimer), this.pingTimeoutTimer = this.setTimeoutFn(() => {
      this.onClose("ping timeout");
    }, this.pingInterval + this.pingTimeout), this.opts.autoUnref && this.pingTimeoutTimer.unref();
  }
  onDrain() {
    this.writeBuffer.splice(0, this.prevBufferLen), this.prevBufferLen = 0, this.writeBuffer.length === 0 ? this.emitReserved("drain") : this.flush();
  }
  flush() {
    if (this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      const e = this.getWritablePackets();
      this.transport.send(e), this.prevBufferLen = e.length, this.emitReserved("flush");
    }
  }
  getWritablePackets() {
    if (!(this.maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1))
      return this.writeBuffer;
    let t = 1;
    for (let r = 0; r < this.writeBuffer.length; r++) {
      const s = this.writeBuffer[r].data;
      if (s && (t += Io(s)), r > 0 && t > this.maxPayload)
        return this.writeBuffer.slice(0, r);
      t += 2;
    }
    return this.writeBuffer;
  }
  write(e, t, r) {
    return this.sendPacket("message", e, t, r), this;
  }
  send(e, t, r) {
    return this.sendPacket("message", e, t, r), this;
  }
  sendPacket(e, t, r, s) {
    if (typeof t == "function" && (s = t, t = void 0), typeof r == "function" && (s = r, r = null), this.readyState === "closing" || this.readyState === "closed")
      return;
    r = r || {}, r.compress = r.compress !== !1;
    const i = {
      type: e,
      data: t,
      options: r
    };
    this.emitReserved("packetCreate", i), this.writeBuffer.push(i), s && this.once("flush", s), this.flush();
  }
  close() {
    const e = () => {
      this.onClose("forced close"), this.transport.close();
    }, t = () => {
      this.off("upgrade", t), this.off("upgradeError", t), e();
    }, r = () => {
      this.once("upgrade", t), this.once("upgradeError", t);
    };
    return (this.readyState === "opening" || this.readyState === "open") && (this.readyState = "closing", this.writeBuffer.length ? this.once("drain", () => {
      this.upgrading ? r() : e();
    }) : this.upgrading ? r() : e()), this;
  }
  onError(e) {
    xe.priorWebsocketSuccess = !1, this.emitReserved("error", e), this.onClose("transport error", e);
  }
  onClose(e, t) {
    (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") && (this.clearTimeoutFn(this.pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), typeof removeEventListener == "function" && (removeEventListener("beforeunload", this.beforeunloadEventListener, !1), removeEventListener("offline", this.offlineEventListener, !1)), this.readyState = "closed", this.id = null, this.emitReserved("close", e, t), this.writeBuffer = [], this.prevBufferLen = 0);
  }
  filterUpgrades(e) {
    const t = [];
    let r = 0;
    const s = e.length;
    for (; r < s; r++)
      ~this.transports.indexOf(e[r]) && t.push(e[r]);
    return t;
  }
}
xe.protocol = ls;
function Zo(n, e = "", t) {
  let r = n;
  t = t || typeof location < "u" && location, n == null && (n = t.protocol + "//" + t.host), typeof n == "string" && (n.charAt(0) === "/" && (n.charAt(1) === "/" ? n = t.protocol + n : n = t.host + n), /^(https?|wss?):\/\//.test(n) || (typeof t < "u" ? n = t.protocol + "//" + n : n = "https://" + n), r = Rn(n)), r.port || (/^(http|ws)$/.test(r.protocol) ? r.port = "80" : /^(http|ws)s$/.test(r.protocol) && (r.port = "443")), r.path = r.path || "/";
  const i = r.host.indexOf(":") !== -1 ? "[" + r.host + "]" : r.host;
  return r.id = r.protocol + "://" + i + ":" + r.port + e, r.href = r.protocol + "://" + i + (t && t.port === r.port ? "" : ":" + r.port), r;
}
const ea = typeof ArrayBuffer == "function", ta = (n) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(n) : n.buffer instanceof ArrayBuffer, _s = Object.prototype.toString, na = typeof Blob == "function" || typeof Blob < "u" && _s.call(Blob) === "[object BlobConstructor]", ra = typeof File == "function" || typeof File < "u" && _s.call(File) === "[object FileConstructor]";
function Bn(n) {
  return ea && (n instanceof ArrayBuffer || ta(n)) || na && n instanceof Blob || ra && n instanceof File;
}
function At(n, e) {
  if (!n || typeof n != "object")
    return !1;
  if (Array.isArray(n)) {
    for (let t = 0, r = n.length; t < r; t++)
      if (At(n[t]))
        return !0;
    return !1;
  }
  if (Bn(n))
    return !0;
  if (n.toJSON && typeof n.toJSON == "function" && arguments.length === 1)
    return At(n.toJSON(), !0);
  for (const t in n)
    if (Object.prototype.hasOwnProperty.call(n, t) && At(n[t]))
      return !0;
  return !1;
}
function sa(n) {
  const e = [], t = n.data, r = n;
  return r.data = Sn(t, e), r.attachments = e.length, { packet: r, buffers: e };
}
function Sn(n, e) {
  if (!n)
    return n;
  if (Bn(n)) {
    const t = { _placeholder: !0, num: e.length };
    return e.push(n), t;
  } else if (Array.isArray(n)) {
    const t = new Array(n.length);
    for (let r = 0; r < n.length; r++)
      t[r] = Sn(n[r], e);
    return t;
  } else if (typeof n == "object" && !(n instanceof Date)) {
    const t = {};
    for (const r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (t[r] = Sn(n[r], e));
    return t;
  }
  return n;
}
function ia(n, e) {
  return n.data = Tn(n.data, e), delete n.attachments, n;
}
function Tn(n, e) {
  if (!n)
    return n;
  if (n && n._placeholder === !0) {
    if (typeof n.num == "number" && n.num >= 0 && n.num < e.length)
      return e[n.num];
    throw new Error("illegal attachments");
  } else if (Array.isArray(n))
    for (let t = 0; t < n.length; t++)
      n[t] = Tn(n[t], e);
  else if (typeof n == "object")
    for (const t in n)
      Object.prototype.hasOwnProperty.call(n, t) && (n[t] = Tn(n[t], e));
  return n;
}
const oa = 5;
var O;
(function(n) {
  n[n.CONNECT = 0] = "CONNECT", n[n.DISCONNECT = 1] = "DISCONNECT", n[n.EVENT = 2] = "EVENT", n[n.ACK = 3] = "ACK", n[n.CONNECT_ERROR = 4] = "CONNECT_ERROR", n[n.BINARY_EVENT = 5] = "BINARY_EVENT", n[n.BINARY_ACK = 6] = "BINARY_ACK";
})(O || (O = {}));
class aa {
  constructor(e) {
    this.replacer = e;
  }
  encode(e) {
    return (e.type === O.EVENT || e.type === O.ACK) && At(e) ? this.encodeAsBinary({
      type: e.type === O.EVENT ? O.BINARY_EVENT : O.BINARY_ACK,
      nsp: e.nsp,
      data: e.data,
      id: e.id
    }) : [this.encodeAsString(e)];
  }
  encodeAsString(e) {
    let t = "" + e.type;
    return (e.type === O.BINARY_EVENT || e.type === O.BINARY_ACK) && (t += e.attachments + "-"), e.nsp && e.nsp !== "/" && (t += e.nsp + ","), e.id != null && (t += e.id), e.data != null && (t += JSON.stringify(e.data, this.replacer)), t;
  }
  encodeAsBinary(e) {
    const t = sa(e), r = this.encodeAsString(t.packet), s = t.buffers;
    return s.unshift(r), s;
  }
}
class Fn extends Y {
  constructor(e) {
    super(), this.reviver = e;
  }
  add(e) {
    let t;
    if (typeof e == "string") {
      if (this.reconstructor)
        throw new Error("got plaintext data when reconstructing a packet");
      t = this.decodeString(e);
      const r = t.type === O.BINARY_EVENT;
      r || t.type === O.BINARY_ACK ? (t.type = r ? O.EVENT : O.ACK, this.reconstructor = new ua(t), t.attachments === 0 && super.emitReserved("decoded", t)) : super.emitReserved("decoded", t);
    } else if (Bn(e) || e.base64)
      if (this.reconstructor)
        t = this.reconstructor.takeBinaryData(e), t && (this.reconstructor = null, super.emitReserved("decoded", t));
      else
        throw new Error("got binary data when not reconstructing a packet");
    else
      throw new Error("Unknown type: " + e);
  }
  decodeString(e) {
    let t = 0;
    const r = {
      type: Number(e.charAt(0))
    };
    if (O[r.type] === void 0)
      throw new Error("unknown packet type " + r.type);
    if (r.type === O.BINARY_EVENT || r.type === O.BINARY_ACK) {
      const i = t + 1;
      for (; e.charAt(++t) !== "-" && t != e.length; )
        ;
      const o = e.substring(i, t);
      if (o != Number(o) || e.charAt(t) !== "-")
        throw new Error("Illegal attachments");
      r.attachments = Number(o);
    }
    if (e.charAt(t + 1) === "/") {
      const i = t + 1;
      for (; ++t && !(e.charAt(t) === "," || t === e.length); )
        ;
      r.nsp = e.substring(i, t);
    } else
      r.nsp = "/";
    const s = e.charAt(t + 1);
    if (s !== "" && Number(s) == s) {
      const i = t + 1;
      for (; ++t; ) {
        const o = e.charAt(t);
        if (o == null || Number(o) != o) {
          --t;
          break;
        }
        if (t === e.length)
          break;
      }
      r.id = Number(e.substring(i, t + 1));
    }
    if (e.charAt(++t)) {
      const i = this.tryParse(e.substr(t));
      if (Fn.isPayloadValid(r.type, i))
        r.data = i;
      else
        throw new Error("invalid payload");
    }
    return r;
  }
  tryParse(e) {
    try {
      return JSON.parse(e, this.reviver);
    } catch {
      return !1;
    }
  }
  static isPayloadValid(e, t) {
    switch (e) {
      case O.CONNECT:
        return typeof t == "object";
      case O.DISCONNECT:
        return t === void 0;
      case O.CONNECT_ERROR:
        return typeof t == "string" || typeof t == "object";
      case O.EVENT:
      case O.BINARY_EVENT:
        return Array.isArray(t) && (typeof t[0] == "string" || typeof t[0] == "number");
      case O.ACK:
      case O.BINARY_ACK:
        return Array.isArray(t);
    }
  }
  destroy() {
    this.reconstructor && (this.reconstructor.finishedReconstruction(), this.reconstructor = null);
  }
}
class ua {
  constructor(e) {
    this.packet = e, this.buffers = [], this.reconPack = e;
  }
  takeBinaryData(e) {
    if (this.buffers.push(e), this.buffers.length === this.reconPack.attachments) {
      const t = ia(this.reconPack, this.buffers);
      return this.finishedReconstruction(), t;
    }
    return null;
  }
  finishedReconstruction() {
    this.reconPack = null, this.buffers = [];
  }
}
const ca = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  protocol: oa,
  get PacketType() {
    return O;
  },
  Encoder: aa,
  Decoder: Fn
}, Symbol.toStringTag, { value: "Module" }));
function de(n, e, t) {
  return n.on(e, t), function() {
    n.off(e, t);
  };
}
const la = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  newListener: 1,
  removeListener: 1
});
class bs extends Y {
  constructor(e, t, r) {
    super(), this.connected = !1, this.recovered = !1, this.receiveBuffer = [], this.sendBuffer = [], this._queue = [], this._queueSeq = 0, this.ids = 0, this.acks = {}, this.flags = {}, this.io = e, this.nsp = t, r && r.auth && (this.auth = r.auth), this._opts = Object.assign({}, r), this.io._autoConnect && this.open();
  }
  get disconnected() {
    return !this.connected;
  }
  subEvents() {
    if (this.subs)
      return;
    const e = this.io;
    this.subs = [
      de(e, "open", this.onopen.bind(this)),
      de(e, "packet", this.onpacket.bind(this)),
      de(e, "error", this.onerror.bind(this)),
      de(e, "close", this.onclose.bind(this))
    ];
  }
  get active() {
    return !!this.subs;
  }
  connect() {
    return this.connected ? this : (this.subEvents(), this.io._reconnecting || this.io.open(), this.io._readyState === "open" && this.onopen(), this);
  }
  open() {
    return this.connect();
  }
  send(...e) {
    return e.unshift("message"), this.emit.apply(this, e), this;
  }
  emit(e, ...t) {
    if (la.hasOwnProperty(e))
      throw new Error('"' + e.toString() + '" is a reserved event name');
    if (t.unshift(e), this._opts.retries && !this.flags.fromQueue && !this.flags.volatile)
      return this._addToQueue(t), this;
    const r = {
      type: O.EVENT,
      data: t
    };
    if (r.options = {}, r.options.compress = this.flags.compress !== !1, typeof t[t.length - 1] == "function") {
      const o = this.ids++, c = t.pop();
      this._registerAckCallback(o, c), r.id = o;
    }
    const s = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
    return this.flags.volatile && (!s || !this.connected) || (this.connected ? (this.notifyOutgoingListeners(r), this.packet(r)) : this.sendBuffer.push(r)), this.flags = {}, this;
  }
  _registerAckCallback(e, t) {
    var r;
    const s = (r = this.flags.timeout) !== null && r !== void 0 ? r : this._opts.ackTimeout;
    if (s === void 0) {
      this.acks[e] = t;
      return;
    }
    const i = this.io.setTimeoutFn(() => {
      delete this.acks[e];
      for (let o = 0; o < this.sendBuffer.length; o++)
        this.sendBuffer[o].id === e && this.sendBuffer.splice(o, 1);
      t.call(this, new Error("operation has timed out"));
    }, s);
    this.acks[e] = (...o) => {
      this.io.clearTimeoutFn(i), t.apply(this, [null, ...o]);
    };
  }
  emitWithAck(e, ...t) {
    const r = this.flags.timeout !== void 0 || this._opts.ackTimeout !== void 0;
    return new Promise((s, i) => {
      t.push((o, c) => r ? o ? i(o) : s(c) : s(o)), this.emit(e, ...t);
    });
  }
  _addToQueue(e) {
    let t;
    typeof e[e.length - 1] == "function" && (t = e.pop());
    const r = {
      id: this._queueSeq++,
      tryCount: 0,
      pending: !1,
      args: e,
      flags: Object.assign({ fromQueue: !0 }, this.flags)
    };
    e.push((s, ...i) => r !== this._queue[0] ? void 0 : (s !== null ? r.tryCount > this._opts.retries && (this._queue.shift(), t && t(s)) : (this._queue.shift(), t && t(null, ...i)), r.pending = !1, this._drainQueue())), this._queue.push(r), this._drainQueue();
  }
  _drainQueue(e = !1) {
    if (!this.connected || this._queue.length === 0)
      return;
    const t = this._queue[0];
    t.pending && !e || (t.pending = !0, t.tryCount++, this.flags = t.flags, this.emit.apply(this, t.args));
  }
  packet(e) {
    e.nsp = this.nsp, this.io._packet(e);
  }
  onopen() {
    typeof this.auth == "function" ? this.auth((e) => {
      this._sendConnectPacket(e);
    }) : this._sendConnectPacket(this.auth);
  }
  _sendConnectPacket(e) {
    this.packet({
      type: O.CONNECT,
      data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, e) : e
    });
  }
  onerror(e) {
    this.connected || this.emitReserved("connect_error", e);
  }
  onclose(e, t) {
    this.connected = !1, delete this.id, this.emitReserved("disconnect", e, t);
  }
  onpacket(e) {
    if (e.nsp === this.nsp)
      switch (e.type) {
        case O.CONNECT:
          e.data && e.data.sid ? this.onconnect(e.data.sid, e.data.pid) : this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
          break;
        case O.EVENT:
        case O.BINARY_EVENT:
          this.onevent(e);
          break;
        case O.ACK:
        case O.BINARY_ACK:
          this.onack(e);
          break;
        case O.DISCONNECT:
          this.ondisconnect();
          break;
        case O.CONNECT_ERROR:
          this.destroy();
          const r = new Error(e.data.message);
          r.data = e.data.data, this.emitReserved("connect_error", r);
          break;
      }
  }
  onevent(e) {
    const t = e.data || [];
    e.id != null && t.push(this.ack(e.id)), this.connected ? this.emitEvent(t) : this.receiveBuffer.push(Object.freeze(t));
  }
  emitEvent(e) {
    if (this._anyListeners && this._anyListeners.length) {
      const t = this._anyListeners.slice();
      for (const r of t)
        r.apply(this, e);
    }
    super.emit.apply(this, e), this._pid && e.length && typeof e[e.length - 1] == "string" && (this._lastOffset = e[e.length - 1]);
  }
  ack(e) {
    const t = this;
    let r = !1;
    return function(...s) {
      r || (r = !0, t.packet({
        type: O.ACK,
        id: e,
        data: s
      }));
    };
  }
  onack(e) {
    const t = this.acks[e.id];
    typeof t == "function" && (t.apply(this, e.data), delete this.acks[e.id]);
  }
  onconnect(e, t) {
    this.id = e, this.recovered = t && this._pid === t, this._pid = t, this.connected = !0, this.emitBuffered(), this.emitReserved("connect"), this._drainQueue(!0);
  }
  emitBuffered() {
    this.receiveBuffer.forEach((e) => this.emitEvent(e)), this.receiveBuffer = [], this.sendBuffer.forEach((e) => {
      this.notifyOutgoingListeners(e), this.packet(e);
    }), this.sendBuffer = [];
  }
  ondisconnect() {
    this.destroy(), this.onclose("io server disconnect");
  }
  destroy() {
    this.subs && (this.subs.forEach((e) => e()), this.subs = void 0), this.io._destroy(this);
  }
  disconnect() {
    return this.connected && this.packet({ type: O.DISCONNECT }), this.destroy(), this.connected && this.onclose("io client disconnect"), this;
  }
  close() {
    return this.disconnect();
  }
  compress(e) {
    return this.flags.compress = e, this;
  }
  get volatile() {
    return this.flags.volatile = !0, this;
  }
  timeout(e) {
    return this.flags.timeout = e, this;
  }
  onAny(e) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.push(e), this;
  }
  prependAny(e) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.unshift(e), this;
  }
  offAny(e) {
    if (!this._anyListeners)
      return this;
    if (e) {
      const t = this._anyListeners;
      for (let r = 0; r < t.length; r++)
        if (e === t[r])
          return t.splice(r, 1), this;
    } else
      this._anyListeners = [];
    return this;
  }
  listenersAny() {
    return this._anyListeners || [];
  }
  onAnyOutgoing(e) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.push(e), this;
  }
  prependAnyOutgoing(e) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.unshift(e), this;
  }
  offAnyOutgoing(e) {
    if (!this._anyOutgoingListeners)
      return this;
    if (e) {
      const t = this._anyOutgoingListeners;
      for (let r = 0; r < t.length; r++)
        if (e === t[r])
          return t.splice(r, 1), this;
    } else
      this._anyOutgoingListeners = [];
    return this;
  }
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  notifyOutgoingListeners(e) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const t = this._anyOutgoingListeners.slice();
      for (const r of t)
        r.apply(this, e.data);
    }
  }
}
function ze(n) {
  n = n || {}, this.ms = n.min || 100, this.max = n.max || 1e4, this.factor = n.factor || 2, this.jitter = n.jitter > 0 && n.jitter <= 1 ? n.jitter : 0, this.attempts = 0;
}
ze.prototype.duration = function() {
  var n = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var e = Math.random(), t = Math.floor(e * this.jitter * n);
    n = (Math.floor(e * 10) & 1) == 0 ? n - t : n + t;
  }
  return Math.min(n, this.max) | 0;
};
ze.prototype.reset = function() {
  this.attempts = 0;
};
ze.prototype.setMin = function(n) {
  this.ms = n;
};
ze.prototype.setMax = function(n) {
  this.max = n;
};
ze.prototype.setJitter = function(n) {
  this.jitter = n;
};
class On extends Y {
  constructor(e, t) {
    var r;
    super(), this.nsps = {}, this.subs = [], e && typeof e == "object" && (t = e, e = void 0), t = t || {}, t.path = t.path || "/socket.io", this.opts = t, qt(this, t), this.reconnection(t.reconnection !== !1), this.reconnectionAttempts(t.reconnectionAttempts || 1 / 0), this.reconnectionDelay(t.reconnectionDelay || 1e3), this.reconnectionDelayMax(t.reconnectionDelayMax || 5e3), this.randomizationFactor((r = t.randomizationFactor) !== null && r !== void 0 ? r : 0.5), this.backoff = new ze({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    }), this.timeout(t.timeout == null ? 2e4 : t.timeout), this._readyState = "closed", this.uri = e;
    const s = t.parser || ca;
    this.encoder = new s.Encoder(), this.decoder = new s.Decoder(), this._autoConnect = t.autoConnect !== !1, this._autoConnect && this.open();
  }
  reconnection(e) {
    return arguments.length ? (this._reconnection = !!e, this) : this._reconnection;
  }
  reconnectionAttempts(e) {
    return e === void 0 ? this._reconnectionAttempts : (this._reconnectionAttempts = e, this);
  }
  reconnectionDelay(e) {
    var t;
    return e === void 0 ? this._reconnectionDelay : (this._reconnectionDelay = e, (t = this.backoff) === null || t === void 0 || t.setMin(e), this);
  }
  randomizationFactor(e) {
    var t;
    return e === void 0 ? this._randomizationFactor : (this._randomizationFactor = e, (t = this.backoff) === null || t === void 0 || t.setJitter(e), this);
  }
  reconnectionDelayMax(e) {
    var t;
    return e === void 0 ? this._reconnectionDelayMax : (this._reconnectionDelayMax = e, (t = this.backoff) === null || t === void 0 || t.setMax(e), this);
  }
  timeout(e) {
    return arguments.length ? (this._timeout = e, this) : this._timeout;
  }
  maybeReconnectOnOpen() {
    !this._reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect();
  }
  open(e) {
    if (~this._readyState.indexOf("open"))
      return this;
    this.engine = new xe(this.uri, this.opts);
    const t = this.engine, r = this;
    this._readyState = "opening", this.skipReconnect = !1;
    const s = de(t, "open", function() {
      r.onopen(), e && e();
    }), i = de(t, "error", (o) => {
      r.cleanup(), r._readyState = "closed", this.emitReserved("error", o), e ? e(o) : r.maybeReconnectOnOpen();
    });
    if (this._timeout !== !1) {
      const o = this._timeout;
      o === 0 && s();
      const c = this.setTimeoutFn(() => {
        s(), t.close(), t.emit("error", new Error("timeout"));
      }, o);
      this.opts.autoUnref && c.unref(), this.subs.push(function() {
        clearTimeout(c);
      });
    }
    return this.subs.push(s), this.subs.push(i), this;
  }
  connect(e) {
    return this.open(e);
  }
  onopen() {
    this.cleanup(), this._readyState = "open", this.emitReserved("open");
    const e = this.engine;
    this.subs.push(de(e, "ping", this.onping.bind(this)), de(e, "data", this.ondata.bind(this)), de(e, "error", this.onerror.bind(this)), de(e, "close", this.onclose.bind(this)), de(this.decoder, "decoded", this.ondecoded.bind(this)));
  }
  onping() {
    this.emitReserved("ping");
  }
  ondata(e) {
    try {
      this.decoder.add(e);
    } catch (t) {
      this.onclose("parse error", t);
    }
  }
  ondecoded(e) {
    gs(() => {
      this.emitReserved("packet", e);
    }, this.setTimeoutFn);
  }
  onerror(e) {
    this.emitReserved("error", e);
  }
  socket(e, t) {
    let r = this.nsps[e];
    return r ? this._autoConnect && !r.active && r.connect() : (r = new bs(this, e, t), this.nsps[e] = r), r;
  }
  _destroy(e) {
    const t = Object.keys(this.nsps);
    for (const r of t)
      if (this.nsps[r].active)
        return;
    this._close();
  }
  _packet(e) {
    const t = this.encoder.encode(e);
    for (let r = 0; r < t.length; r++)
      this.engine.write(t[r], e.options);
  }
  cleanup() {
    this.subs.forEach((e) => e()), this.subs.length = 0, this.decoder.destroy();
  }
  _close() {
    this.skipReconnect = !0, this._reconnecting = !1, this.onclose("forced close"), this.engine && this.engine.close();
  }
  disconnect() {
    return this._close();
  }
  onclose(e, t) {
    this.cleanup(), this.backoff.reset(), this._readyState = "closed", this.emitReserved("close", e, t), this._reconnection && !this.skipReconnect && this.reconnect();
  }
  reconnect() {
    if (this._reconnecting || this.skipReconnect)
      return this;
    const e = this;
    if (this.backoff.attempts >= this._reconnectionAttempts)
      this.backoff.reset(), this.emitReserved("reconnect_failed"), this._reconnecting = !1;
    else {
      const t = this.backoff.duration();
      this._reconnecting = !0;
      const r = this.setTimeoutFn(() => {
        e.skipReconnect || (this.emitReserved("reconnect_attempt", e.backoff.attempts), !e.skipReconnect && e.open((s) => {
          s ? (e._reconnecting = !1, e.reconnect(), this.emitReserved("reconnect_error", s)) : e.onreconnect();
        }));
      }, t);
      this.opts.autoUnref && r.unref(), this.subs.push(function() {
        clearTimeout(r);
      });
    }
  }
  onreconnect() {
    const e = this.backoff.attempts;
    this._reconnecting = !1, this.backoff.reset(), this.emitReserved("reconnect", e);
  }
}
const nt = {};
function kt(n, e) {
  typeof n == "object" && (e = n, n = void 0), e = e || {};
  const t = Zo(n, e.path || "/socket.io"), r = t.source, s = t.id, i = t.path, o = nt[s] && i in nt[s].nsps, c = e.forceNew || e["force new connection"] || e.multiplex === !1 || o;
  let f;
  return c ? f = new On(r, e) : (nt[s] || (nt[s] = new On(r, e)), f = nt[s]), t.query && !e.query && (e.query = t.queryKey), f.socket(t.path, e);
}
Object.assign(kt, {
  Manager: On,
  Socket: bs,
  io: kt,
  connect: kt
});
class fa {
  constructor(e, t) {
    Le(this, "socket_port");
    Le(this, "host");
    Le(this, "port");
    Le(this, "protocol");
    Le(this, "url");
    Le(this, "socket");
    this.socket_port = t != null ? t : "9000", this.host = window.location.hostname, this.port = window.location.port ? `:${this.socket_port}` : "", this.protocol = this.port ? "http" : "https", this.url = e || `${this.protocol}://${this.host}${this.port}`, this.socket = kt(this.url, { withCredentials: !0 });
  }
}
var ws = { exports: {} }, rt = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Dr;
function ha() {
  if (Dr)
    return rt;
  Dr = 1;
  var n = Ye, e = Symbol.for("react.element"), t = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, s = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function o(c, f, a) {
    var h, l = {}, v = null, p = null;
    a !== void 0 && (v = "" + a), f.key !== void 0 && (v = "" + f.key), f.ref !== void 0 && (p = f.ref);
    for (h in f)
      r.call(f, h) && !i.hasOwnProperty(h) && (l[h] = f[h]);
    if (c && c.defaultProps)
      for (h in f = c.defaultProps, f)
        l[h] === void 0 && (l[h] = f[h]);
    return { $$typeof: e, type: c, key: v, ref: p, props: l, _owner: s.current };
  }
  return rt.Fragment = t, rt.jsx = o, rt.jsxs = o, rt;
}
var st = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Lr;
function da() {
  return Lr || (Lr = 1, process.env.NODE_ENV !== "production" && function() {
    var n = Ye, e = Symbol.for("react.element"), t = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), s = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), c = Symbol.for("react.context"), f = Symbol.for("react.forward_ref"), a = Symbol.for("react.suspense"), h = Symbol.for("react.suspense_list"), l = Symbol.for("react.memo"), v = Symbol.for("react.lazy"), p = Symbol.for("react.offscreen"), b = Symbol.iterator, w = "@@iterator";
    function g(u) {
      if (u === null || typeof u != "object")
        return null;
      var d = b && u[b] || u[w];
      return typeof d == "function" ? d : null;
    }
    var L = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function R(u) {
      {
        for (var d = arguments.length, y = new Array(d > 1 ? d - 1 : 0), _ = 1; _ < d; _++)
          y[_ - 1] = arguments[_];
        A("error", u, y);
      }
    }
    function A(u, d, y) {
      {
        var _ = L.ReactDebugCurrentFrame, C = _.getStackAddendum();
        C !== "" && (d += "%s", y = y.concat([C]));
        var P = y.map(function(x) {
          return String(x);
        });
        P.unshift("Warning: " + d), Function.prototype.apply.call(console[u], console, P);
      }
    }
    var m = !1, $ = !1, E = !1, S = !1, K = !1, N;
    N = Symbol.for("react.module.reference");
    function B(u) {
      return !!(typeof u == "string" || typeof u == "function" || u === r || u === i || K || u === s || u === a || u === h || S || u === p || m || $ || E || typeof u == "object" && u !== null && (u.$$typeof === v || u.$$typeof === l || u.$$typeof === o || u.$$typeof === c || u.$$typeof === f || u.$$typeof === N || u.getModuleId !== void 0));
    }
    function re(u, d, y) {
      var _ = u.displayName;
      if (_)
        return _;
      var C = d.displayName || d.name || "";
      return C !== "" ? y + "(" + C + ")" : y;
    }
    function Z(u) {
      return u.displayName || "Context";
    }
    function q(u) {
      if (u == null)
        return null;
      if (typeof u.tag == "number" && R("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof u == "function")
        return u.displayName || u.name || null;
      if (typeof u == "string")
        return u;
      switch (u) {
        case r:
          return "Fragment";
        case t:
          return "Portal";
        case i:
          return "Profiler";
        case s:
          return "StrictMode";
        case a:
          return "Suspense";
        case h:
          return "SuspenseList";
      }
      if (typeof u == "object")
        switch (u.$$typeof) {
          case c:
            var d = u;
            return Z(d) + ".Consumer";
          case o:
            var y = u;
            return Z(y._context) + ".Provider";
          case f:
            return re(u, u.render, "ForwardRef");
          case l:
            var _ = u.displayName || null;
            return _ !== null ? _ : q(u.type) || "Memo";
          case v: {
            var C = u, P = C._payload, x = C._init;
            try {
              return q(x(P));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var ee = Object.assign, ue = 0, Ke, ge, Ge, dt, _e, be, De;
    function Xe() {
    }
    Xe.__reactDisabledLog = !0;
    function Qe() {
      {
        if (ue === 0) {
          Ke = console.log, ge = console.info, Ge = console.warn, dt = console.error, _e = console.group, be = console.groupCollapsed, De = console.groupEnd;
          var u = {
            configurable: !0,
            enumerable: !0,
            value: Xe,
            writable: !0
          };
          Object.defineProperties(console, {
            info: u,
            log: u,
            warn: u,
            error: u,
            group: u,
            groupCollapsed: u,
            groupEnd: u
          });
        }
        ue++;
      }
    }
    function pt() {
      {
        if (ue--, ue === 0) {
          var u = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: ee({}, u, {
              value: Ke
            }),
            info: ee({}, u, {
              value: ge
            }),
            warn: ee({}, u, {
              value: Ge
            }),
            error: ee({}, u, {
              value: dt
            }),
            group: ee({}, u, {
              value: _e
            }),
            groupCollapsed: ee({}, u, {
              value: be
            }),
            groupEnd: ee({}, u, {
              value: De
            })
          });
        }
        ue < 0 && R("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Fe = L.ReactCurrentDispatcher, Ze;
    function Ie(u, d, y) {
      {
        if (Ze === void 0)
          try {
            throw Error();
          } catch (C) {
            var _ = C.stack.trim().match(/\n( *(at )?)/);
            Ze = _ && _[1] || "";
          }
        return `
` + Ze + u;
      }
    }
    var we = !1, qe;
    {
      var F = typeof WeakMap == "function" ? WeakMap : Map;
      qe = new F();
    }
    function j(u, d) {
      if (!u || we)
        return "";
      {
        var y = qe.get(u);
        if (y !== void 0)
          return y;
      }
      var _;
      we = !0;
      var C = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var P;
      P = Fe.current, Fe.current = null, Qe();
      try {
        if (d) {
          var x = function() {
            throw Error();
          };
          if (Object.defineProperty(x.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(x, []);
            } catch (Re) {
              _ = Re;
            }
            Reflect.construct(u, [], x);
          } else {
            try {
              x.call();
            } catch (Re) {
              _ = Re;
            }
            u.call(x.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Re) {
            _ = Re;
          }
          u();
        }
      } catch (Re) {
        if (Re && _ && typeof Re.stack == "string") {
          for (var T = Re.stack.split(`
`), ne = _.stack.split(`
`), M = T.length - 1, H = ne.length - 1; M >= 1 && H >= 0 && T[M] !== ne[H]; )
            H--;
          for (; M >= 1 && H >= 0; M--, H--)
            if (T[M] !== ne[H]) {
              if (M !== 1 || H !== 1)
                do
                  if (M--, H--, H < 0 || T[M] !== ne[H]) {
                    var ce = `
` + T[M].replace(" at new ", " at ");
                    return u.displayName && ce.includes("<anonymous>") && (ce = ce.replace("<anonymous>", u.displayName)), typeof u == "function" && qe.set(u, ce), ce;
                  }
                while (M >= 1 && H >= 0);
              break;
            }
        }
      } finally {
        we = !1, Fe.current = P, pt(), Error.prepareStackTrace = C;
      }
      var $e = u ? u.displayName || u.name : "", Hn = $e ? Ie($e) : "";
      return typeof u == "function" && qe.set(u, Hn), Hn;
    }
    function J(u, d, y) {
      return j(u, !1);
    }
    function U(u) {
      var d = u.prototype;
      return !!(d && d.isReactComponent);
    }
    function te(u, d, y) {
      if (u == null)
        return "";
      if (typeof u == "function")
        return j(u, U(u));
      if (typeof u == "string")
        return Ie(u);
      switch (u) {
        case a:
          return Ie("Suspense");
        case h:
          return Ie("SuspenseList");
      }
      if (typeof u == "object")
        switch (u.$$typeof) {
          case f:
            return J(u.render);
          case l:
            return te(u.type, d, y);
          case v: {
            var _ = u, C = _._payload, P = _._init;
            try {
              return te(P(C), d, y);
            } catch {
            }
          }
        }
      return "";
    }
    var fe = Object.prototype.hasOwnProperty, W = {}, z = L.ReactDebugCurrentFrame;
    function se(u) {
      if (u) {
        var d = u._owner, y = te(u.type, u._source, d ? d.type : null);
        z.setExtraStackFrame(y);
      } else
        z.setExtraStackFrame(null);
    }
    function vt(u, d, y, _, C) {
      {
        var P = Function.call.bind(fe);
        for (var x in u)
          if (P(u, x)) {
            var T = void 0;
            try {
              if (typeof u[x] != "function") {
                var ne = Error((_ || "React class") + ": " + y + " type `" + x + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof u[x] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw ne.name = "Invariant Violation", ne;
              }
              T = u[x](d, x, _, y, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (M) {
              T = M;
            }
            T && !(T instanceof Error) && (se(C), R("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", _ || "React class", y, x, typeof T), se(null)), T instanceof Error && !(T.message in W) && (W[T.message] = !0, se(C), R("Failed %s type: %s", y, T.message), se(null));
          }
      }
    }
    var mt = Array.isArray;
    function Ue(u) {
      return mt(u);
    }
    function ie(u) {
      {
        var d = typeof Symbol == "function" && Symbol.toStringTag, y = d && u[Symbol.toStringTag] || u.constructor.name || "Object";
        return y;
      }
    }
    function he(u) {
      try {
        return Ve(u), !1;
      } catch {
        return !0;
      }
    }
    function Ve(u) {
      return "" + u;
    }
    function yt(u) {
      if (he(u))
        return R("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", ie(u)), Ve(u);
    }
    var Ee = L.ReactCurrentOwner, Rs = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, In, qn, Ut;
    Ut = {};
    function Ss(u) {
      if (fe.call(u, "ref")) {
        var d = Object.getOwnPropertyDescriptor(u, "ref").get;
        if (d && d.isReactWarning)
          return !1;
      }
      return u.ref !== void 0;
    }
    function Ts(u) {
      if (fe.call(u, "key")) {
        var d = Object.getOwnPropertyDescriptor(u, "key").get;
        if (d && d.isReactWarning)
          return !1;
      }
      return u.key !== void 0;
    }
    function Os(u, d) {
      if (typeof u.ref == "string" && Ee.current && d && Ee.current.stateNode !== d) {
        var y = q(Ee.current.type);
        Ut[y] || (R('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', q(Ee.current.type), u.ref), Ut[y] = !0);
      }
    }
    function xs(u, d) {
      {
        var y = function() {
          In || (In = !0, R("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", d));
        };
        y.isReactWarning = !0, Object.defineProperty(u, "key", {
          get: y,
          configurable: !0
        });
      }
    }
    function Cs(u, d) {
      {
        var y = function() {
          qn || (qn = !0, R("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", d));
        };
        y.isReactWarning = !0, Object.defineProperty(u, "ref", {
          get: y,
          configurable: !0
        });
      }
    }
    var As = function(u, d, y, _, C, P, x) {
      var T = {
        $$typeof: e,
        type: u,
        key: d,
        ref: y,
        props: x,
        _owner: P
      };
      return T._store = {}, Object.defineProperty(T._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(T, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: _
      }), Object.defineProperty(T, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: C
      }), Object.freeze && (Object.freeze(T.props), Object.freeze(T)), T;
    };
    function ks(u, d, y, _, C) {
      {
        var P, x = {}, T = null, ne = null;
        y !== void 0 && (yt(y), T = "" + y), Ts(d) && (yt(d.key), T = "" + d.key), Ss(d) && (ne = d.ref, Os(d, C));
        for (P in d)
          fe.call(d, P) && !Rs.hasOwnProperty(P) && (x[P] = d[P]);
        if (u && u.defaultProps) {
          var M = u.defaultProps;
          for (P in M)
            x[P] === void 0 && (x[P] = M[P]);
        }
        if (T || ne) {
          var H = typeof u == "function" ? u.displayName || u.name || "Unknown" : u;
          T && xs(x, H), ne && Cs(x, H);
        }
        return As(u, T, ne, C, _, Ee.current, x);
      }
    }
    var Vt = L.ReactCurrentOwner, Un = L.ReactDebugCurrentFrame;
    function je(u) {
      if (u) {
        var d = u._owner, y = te(u.type, u._source, d ? d.type : null);
        Un.setExtraStackFrame(y);
      } else
        Un.setExtraStackFrame(null);
    }
    var jt;
    jt = !1;
    function $t(u) {
      return typeof u == "object" && u !== null && u.$$typeof === e;
    }
    function Vn() {
      {
        if (Vt.current) {
          var u = q(Vt.current.type);
          if (u)
            return `

Check the render method of \`` + u + "`.";
        }
        return "";
      }
    }
    function Ds(u) {
      {
        if (u !== void 0) {
          var d = u.fileName.replace(/^.*[\\\/]/, ""), y = u.lineNumber;
          return `

Check your code at ` + d + ":" + y + ".";
        }
        return "";
      }
    }
    var jn = {};
    function Ls(u) {
      {
        var d = Vn();
        if (!d) {
          var y = typeof u == "string" ? u : u.displayName || u.name;
          y && (d = `

Check the top-level render call using <` + y + ">.");
        }
        return d;
      }
    }
    function $n(u, d) {
      {
        if (!u._store || u._store.validated || u.key != null)
          return;
        u._store.validated = !0;
        var y = Ls(d);
        if (jn[y])
          return;
        jn[y] = !0;
        var _ = "";
        u && u._owner && u._owner !== Vt.current && (_ = " It was passed a child from " + q(u._owner.type) + "."), je(u), R('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', y, _), je(null);
      }
    }
    function Mn(u, d) {
      {
        if (typeof u != "object")
          return;
        if (Ue(u))
          for (var y = 0; y < u.length; y++) {
            var _ = u[y];
            $t(_) && $n(_, d);
          }
        else if ($t(u))
          u._store && (u._store.validated = !0);
        else if (u) {
          var C = g(u);
          if (typeof C == "function" && C !== u.entries)
            for (var P = C.call(u), x; !(x = P.next()).done; )
              $t(x.value) && $n(x.value, d);
        }
      }
    }
    function Ns(u) {
      {
        var d = u.type;
        if (d == null || typeof d == "string")
          return;
        var y;
        if (typeof d == "function")
          y = d.propTypes;
        else if (typeof d == "object" && (d.$$typeof === f || d.$$typeof === l))
          y = d.propTypes;
        else
          return;
        if (y) {
          var _ = q(d);
          vt(y, u.props, "prop", _, u);
        } else if (d.PropTypes !== void 0 && !jt) {
          jt = !0;
          var C = q(d);
          R("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", C || "Unknown");
        }
        typeof d.getDefaultProps == "function" && !d.getDefaultProps.isReactClassApproved && R("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Ps(u) {
      {
        for (var d = Object.keys(u.props), y = 0; y < d.length; y++) {
          var _ = d[y];
          if (_ !== "children" && _ !== "key") {
            je(u), R("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", _), je(null);
            break;
          }
        }
        u.ref !== null && (je(u), R("Invalid attribute `ref` supplied to `React.Fragment`."), je(null));
      }
    }
    function Wn(u, d, y, _, C, P) {
      {
        var x = B(u);
        if (!x) {
          var T = "";
          (u === void 0 || typeof u == "object" && u !== null && Object.keys(u).length === 0) && (T += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var ne = Ds(C);
          ne ? T += ne : T += Vn();
          var M;
          u === null ? M = "null" : Ue(u) ? M = "array" : u !== void 0 && u.$$typeof === e ? (M = "<" + (q(u.type) || "Unknown") + " />", T = " Did you accidentally export a JSX literal instead of a component?") : M = typeof u, R("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", M, T);
        }
        var H = ks(u, d, y, C, P);
        if (H == null)
          return H;
        if (x) {
          var ce = d.children;
          if (ce !== void 0)
            if (_)
              if (Ue(ce)) {
                for (var $e = 0; $e < ce.length; $e++)
                  Mn(ce[$e], u);
                Object.freeze && Object.freeze(ce);
              } else
                R("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Mn(ce, u);
        }
        return u === r ? Ps(H) : Ns(H), H;
      }
    }
    function Bs(u, d, y) {
      return Wn(u, d, y, !0);
    }
    function Fs(u, d, y) {
      return Wn(u, d, y, !1);
    }
    var Is = Fs, qs = Bs;
    st.Fragment = r, st.jsx = Is, st.jsxs = qs;
  }()), st;
}
(function(n) {
  process.env.NODE_ENV === "production" ? n.exports = ha() : n.exports = da();
})(ws);
const pa = ws.exports.jsx, Q = Nr(null), ba = ({
  url: n = "",
  tokenParams: e,
  socketPort: t,
  children: r
}) => {
  const s = Pr(() => {
    const i = new Ji.FrappeApp(n, e);
    return {
      url: n,
      tokenParams: e,
      app: i,
      auth: i.auth(),
      db: i.db(),
      call: i.call(),
      file: i.file(),
      socket: new fa(n, t).socket
    };
  }, [n, e, t]);
  return /* @__PURE__ */ pa(Q.Provider, {
    value: s,
    children: r
  });
}, wa = (n) => {
  const {
    url: e,
    auth: t,
    tokenParams: r
  } = X(Q), [s, i] = D(), o = V(() => {
    const b = document.cookie.split(";").find((w) => w.trim().startsWith("user_id="));
    if (b) {
      const w = b.split("=")[1];
      i(w && w !== "Guest" ? w : null);
    } else
      i(null);
  }, []);
  Je(() => {
    r && r.useToken ? i(null) : o();
  }, []);
  const {
    data: c,
    error: f,
    isLoading: a,
    isValidating: h,
    mutate: l
  } = ht(() => r && r.useToken || s ? `${e}/api/method/frappe.auth.get_logged_user` : null, () => t.getLoggedInUser(), {
    onError: () => {
      i(null);
    },
    shouldRetryOnError: !1,
    revalidateOnFocus: !1,
    ...n
  }), v = V(async (b, w) => t.loginWithUsernamePassword({
    username: b,
    password: w
  }).then((g) => {
    o();
  }), []), p = V(async () => t.logout().then(() => l(null)).then(() => i(null)), []);
  return {
    isLoading: s === void 0 || a,
    currentUser: c,
    isValidating: h,
    error: f,
    login: v,
    logout: p,
    updateCurrentUser: l,
    getUserCookie: o
  };
}, Ea = (n, e, t, r) => {
  const {
    url: s,
    db: i
  } = X(Q);
  return {
    ...ht(t === void 0 ? `${s}/api/resource/${n}/${e}` : t, () => i.getDoc(n, e), r)
  };
}, va = (n) => {
  var t, r, s;
  let e = "";
  if (n != null && n.fields && (e += "fields=" + JSON.stringify(n == null ? void 0 : n.fields) + "&"), n != null && n.filters && (e += "filters=" + JSON.stringify(n == null ? void 0 : n.filters) + "&"), n != null && n.orFilters && (e += "or_filters=" + JSON.stringify(n == null ? void 0 : n.orFilters) + "&"), n != null && n.limit_start && (e += "limit_start=" + JSON.stringify(n == null ? void 0 : n.limit_start) + "&"), n != null && n.limit && (e += "limit=" + JSON.stringify(n == null ? void 0 : n.limit) + "&"), n != null && n.groupBy && (e += "group_by=" + n.groupBy + "&"), n != null && n.orderBy) {
    const i = `${(t = n.orderBy) == null ? void 0 : t.field} ${(s = (r = n.orderBy) == null ? void 0 : r.order) != null ? s : "asc"}`;
    e += "order_by=" + i + "&";
  }
  return n != null && n.asDict && (e += "as_dict=" + n.asDict), e;
}, Ra = (n, e, t, r) => {
  const {
    url: s,
    db: i
  } = X(Q);
  return {
    ...ht(t === void 0 ? `${s}/api/resource/${n}?${va(e)}` : t, () => i.getDocList(n, e), r)
  };
}, Sa = () => {
  const {
    db: n
  } = X(Q), [e, t] = D(!1), [r, s] = D(null), [i, o] = D(!1), c = V(() => {
    t(!1), s(null), o(!1);
  }, []);
  return {
    createDoc: V(async (a, h) => (s(null), o(!1), t(!0), n.createDoc(a, h).then((l) => (t(!1), o(!0), l)).catch((l) => {
      throw t(!1), o(!1), s(l), l;
    })), []),
    loading: e,
    error: r,
    isCompleted: i,
    reset: c
  };
}, Ta = () => {
  const {
    db: n
  } = X(Q), [e, t] = D(!1), [r, s] = D(null), [i, o] = D(!1), c = V(() => {
    t(!1), s(null), o(!1);
  }, []);
  return {
    updateDoc: V(async (a, h, l) => (s(null), o(!1), t(!0), n.updateDoc(a, h, l).then((v) => (t(!1), o(!0), v)).catch((v) => {
      throw t(!1), o(!1), s(v), v;
    })), []),
    loading: e,
    error: r,
    reset: c,
    isCompleted: i
  };
}, Oa = () => {
  const {
    db: n
  } = X(Q), [e, t] = D(!1), [r, s] = D(null), [i, o] = D(!1), c = V(() => {
    t(!1), s(null), o(!1);
  }, []);
  return {
    deleteDoc: V(async (a, h) => (s(null), o(!1), t(!0), n.deleteDoc(a, h).then((l) => (t(!1), o(!0), l)).catch((l) => {
      throw t(!1), o(!1), s(l), l;
    })), []),
    loading: e,
    error: r,
    reset: c,
    isCompleted: i
  };
};
function Es(n) {
  const e = [];
  for (let t in n)
    e.push(encodeURIComponent(t) + "=" + encodeURIComponent(n[t]));
  return e.join("&");
}
const xa = (n, e, t = !1, r = !1, s, i) => {
  const {
    url: o,
    db: c
  } = X(Q);
  return {
    ...ht(s === void 0 ? (() => {
      const h = Es(t ? {
        doctype: n,
        filters: e != null ? e : [],
        cache: t,
        debug: r
      } : {
        doctype: n,
        filters: e != null ? e : [],
        debug: r
      });
      return `${o}/api/method/frappe.client.get_count?${h}`;
    })() : s, () => c.getCount(n, e, t, r), i)
  };
}, ma = (n, e, t, r) => {
  const {
    call: s
  } = X(Q), i = Es(e != null ? e : {}), o = `${n}?${i}`;
  return {
    ...ht(t === void 0 ? o : t, () => s.get(n, e), r)
  };
}, Ca = (n) => {
  const {
    call: e
  } = X(Q), [t, r] = D(null), [s, i] = D(!1), [o, c] = D(null), [f, a] = D(!1), h = V(() => {
    r(null), i(!1), c(null), a(!1);
  }, []);
  return {
    call: V(async (v) => (c(null), a(!1), i(!0), r(null), e.post(n, v).then((p) => (r(p), i(!1), a(!0), p)).catch((p) => {
      throw i(!1), a(!1), c(p), p;
    })), []),
    result: t,
    loading: s,
    error: o,
    reset: h,
    isCompleted: f
  };
}, Aa = (n) => {
  const {
    call: e
  } = X(Q), [t, r] = D(null), [s, i] = D(!1), [o, c] = D(null), [f, a] = D(!1), h = V(() => {
    r(null), i(!1), c(null), a(!1);
  }, []);
  return {
    call: V(async (v) => (c(null), a(!1), i(!0), r(null), e.put(n, v).then((p) => (r(p), i(!1), a(!0), p)).catch((p) => {
      throw i(!1), a(!1), c(p), p;
    })), []),
    result: t,
    loading: s,
    error: o,
    reset: h,
    isCompleted: f
  };
}, ka = (n) => {
  const {
    call: e
  } = X(Q), [t, r] = D(null), [s, i] = D(!1), [o, c] = D(null), [f, a] = D(!1), h = V(() => {
    r(null), i(!1), c(null), a(!1);
  }, []);
  return {
    call: V(async (v) => (c(null), a(!1), i(!0), r(null), e.delete(n, v).then((p) => (r(p), i(!1), a(!0), p)).catch((p) => {
      throw i(!1), a(!1), c(p), p;
    })), []),
    result: t,
    loading: s,
    error: o,
    reset: h,
    isCompleted: f
  };
}, Da = () => {
  const {
    file: n
  } = X(Q), [e, t] = D(0), [r, s] = D(!1), [i, o] = D(null), [c, f] = D(!1), a = V(async (l, v) => (h(), s(!0), n.uploadFile(l, v, (p, b) => t(Math.round(p / b * 100))).then((p) => (f(!0), t(100), s(!1), p.data.message)).catch((p) => {
    throw console.error(p), o(p), s(!1), p;
  })), []), h = V(() => {
    t(0), s(!1), o(null), f(!1);
  }, []);
  return {
    upload: a,
    progress: e,
    loading: r,
    isCompleted: c,
    error: i,
    reset: h
  };
}, La = (n, e, t = [], r = 20, s = 250) => {
  const i = ya(e, s);
  return ma("frappe.desk.search.search_link", {
    doctype: n,
    page_length: r,
    txt: i,
    filters: JSON.stringify(t != null ? t : [])
  });
}, ya = (n, e) => {
  const [t, r] = D(n);
  return Je(() => {
    const s = setTimeout(() => {
      r(n);
    }, e);
    return () => {
      clearTimeout(s);
    };
  }, [n, e]), t;
}, xn = (n, e) => {
  const {
    socket: t
  } = X(Q);
  Je(() => {
    let r = t.on(n, e);
    return () => {
      r.off(n);
    };
  }, [n, e]);
}, Na = (n, e, t = !0, r) => {
  const {
    socket: s
  } = X(Q), [i, o] = D([]);
  Je(() => (s.emit("doc_subscribe", n, e), t && s.emit("doc_open", n, e), () => {
    s.emit("doc_unsubscribe", n, e), t && s.emit("doc_close", n, e);
  }), [n, e, t]), xn("doc_update", r);
  const c = V(() => {
    s.emit("doc_open", n, e);
  }, [n, e]), f = V(() => {
    s.emit("doc_close", n, e);
  }, [n, e]), a = V((h) => {
    h.doctype === n && h.docname === e && o(h.users);
  }, [n, e]);
  return xn("doc_viewers", a), {
    viewers: i,
    emitDocOpen: c,
    emitDocClose: f
  };
}, Pa = (n, e) => {
  const {
    socket: t
  } = X(Q);
  Je(() => (t.emit("doctype_subscribe", n), () => {
    t.emit("doctype_unsubscribe", n);
  }), [n]), xn("list_update", e);
};
export {
  Q as FrappeContext,
  ba as FrappeProvider,
  va as getDocListQueryString,
  wa as useFrappeAuth,
  Sa as useFrappeCreateDoc,
  ka as useFrappeDeleteCall,
  Oa as useFrappeDeleteDoc,
  Pa as useFrappeDocTypeEventListener,
  Na as useFrappeDocumentEventListener,
  xn as useFrappeEventListener,
  Da as useFrappeFileUpload,
  ma as useFrappeGetCall,
  Ea as useFrappeGetDoc,
  xa as useFrappeGetDocCount,
  Ra as useFrappeGetDocList,
  Ca as useFrappePostCall,
  Aa as useFrappePutCall,
  Ta as useFrappeUpdateDoc,
  La as useSearch
};
